<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>carl: carl::vs::detail Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">carl
   &#160;<span id="projectnumber">25.02</span>
   </div>
   <div id="projectbrief">Computer ARithmetic Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('dd/d18/a01284.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">carl::vs::detail Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d0c/a03801.html">Substitution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad68ae6436b21d9a31a10be6e7f3c0194"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d18/a01284.html#ad68ae6436b21d9a31a10be6e7f3c0194">DoubleInterval</a> = <a class="el" href="../../d0/d80/a02281.html">carl::Interval</a>&lt; double &gt;</td></tr>
<tr class="separator:ad68ae6436b21d9a31a10be6e7f3c0194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378ca4c5edeb478a7bc0b51f3ac12cf7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d18/a01284.html#a378ca4c5edeb478a7bc0b51f3ac12cf7">EvalDoubleIntervalMap</a> = std::map&lt; <a class="el" href="../../d5/d88/a02141.html">carl::Variable</a>, <a class="el" href="../../dd/d18/a01284.html#ad68ae6436b21d9a31a10be6e7f3c0194">DoubleInterval</a> &gt;</td></tr>
<tr class="separator:a378ca4c5edeb478a7bc0b51f3ac12cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afbb94a47335dbab9c5e4e9885b35cb75"><td class="memTemplParams" colspan="2">template&lt;class Poly &gt; </td></tr>
<tr class="memitem:afbb94a47335dbab9c5e4e9885b35cb75"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d18/a01284.html#afbb94a47335dbab9c5e4e9885b35cb75">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="../../dc/d0c/a03801.html">Substitution</a>&lt; Poly &gt; &amp;s)</td></tr>
<tr class="separator:afbb94a47335dbab9c5e4e9885b35cb75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd089f7a6e94f345598ceeceb518cd95"><td class="memTemplParams" colspan="2">template&lt;class combineType &gt; </td></tr>
<tr class="memitem:afd089f7a6e94f345598ceeceb518cd95"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d18/a01284.html#afd089f7a6e94f345598ceeceb518cd95">combine</a> (const std::vector&lt; std::vector&lt; std::vector&lt; combineType &gt; &gt; &gt; &amp;_toCombine, std::vector&lt; std::vector&lt; combineType &gt; &gt; &amp;_combination)</td></tr>
<tr class="memdesc:afd089f7a6e94f345598ceeceb518cd95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines vectors.  <a href="../../dd/d18/a01284.html#afd089f7a6e94f345598ceeceb518cd95">More...</a><br /></td></tr>
<tr class="separator:afd089f7a6e94f345598ceeceb518cd95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf8e618e9cdafe85335859e4249c4c6"><td class="memTemplParams" colspan="2">template&lt;typename Poly &gt; </td></tr>
<tr class="memitem:aedf8e618e9cdafe85335859e4249c4c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d18/a01284.html#aedf8e618e9cdafe85335859e4249c4c6">simplify</a> (<a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;)</td></tr>
<tr class="memdesc:aedf8e618e9cdafe85335859e4249c4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies a disjunction of conjunctions of constraints by deleting consistent constraint and inconsistent conjunctions of constraints.  <a href="../../dd/d18/a01284.html#aedf8e618e9cdafe85335859e4249c4c6">More...</a><br /></td></tr>
<tr class="separator:aedf8e618e9cdafe85335859e4249c4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa9d847d04b72d0594ba77c98ad7abb"><td class="memTemplParams" colspan="2">template&lt;typename Poly &gt; </td></tr>
<tr class="memitem:a0fa9d847d04b72d0594ba77c98ad7abb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d18/a01284.html#a0fa9d847d04b72d0594ba77c98ad7abb">simplify</a> (<a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;, <a class="el" href="../../d7/dc5/a01242.html#af041a077115bde1ac2e50ce08365b112">carl::Variables</a> &amp;, const <a class="el" href="../../dd/d18/a01284.html#a378ca4c5edeb478a7bc0b51f3ac12cf7">detail::EvalDoubleIntervalMap</a> &amp;)</td></tr>
<tr class="memdesc:a0fa9d847d04b72d0594ba77c98ad7abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies a disjunction of conjunctions of constraints by deleting consistent constraint and inconsistent conjunctions of constraints.  <a href="../../dd/d18/a01284.html#a0fa9d847d04b72d0594ba77c98ad7abb">More...</a><br /></td></tr>
<tr class="separator:a0fa9d847d04b72d0594ba77c98ad7abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf32e02e57654e0ef292a95560249b8c"><td class="memTemplParams" colspan="2">template&lt;typename Poly &gt; </td></tr>
<tr class="memitem:abf32e02e57654e0ef292a95560249b8c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d18/a01284.html#abf32e02e57654e0ef292a95560249b8c">splitProducts</a> (<a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;, bool=false)</td></tr>
<tr class="memdesc:abf32e02e57654e0ef292a95560249b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits all constraints in the given disjunction of conjunctions of constraints having a non-trivial factorization into a set of constraints which compare the factors instead.  <a href="../../dd/d18/a01284.html#abf32e02e57654e0ef292a95560249b8c">More...</a><br /></td></tr>
<tr class="separator:abf32e02e57654e0ef292a95560249b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28068591855e49e45ab5eca426fef5c6"><td class="memTemplParams" colspan="2">template&lt;typename Poly &gt; </td></tr>
<tr class="memitem:a28068591855e49e45ab5eca426fef5c6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d18/a01284.html#a28068591855e49e45ab5eca426fef5c6">splitProducts</a> (const <a class="el" href="../../d5/da7/a01283.html#a947162a487c857f6f7b2b94d7b1ab627">ConstraintConjunction</a>&lt; Poly &gt; &amp;, <a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;, std::map&lt; const <a class="el" href="../../d8/dde/a03313.html">Constraint</a>&lt; Poly &gt;, <a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt;&gt; &amp;, bool=false)</td></tr>
<tr class="memdesc:a28068591855e49e45ab5eca426fef5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits all constraints in the given conjunction of constraints having a non-trivial factorization into a set of constraints which compare the factors instead.  <a href="../../dd/d18/a01284.html#a28068591855e49e45ab5eca426fef5c6">More...</a><br /></td></tr>
<tr class="separator:a28068591855e49e45ab5eca426fef5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426cbb1daa4c46b55454cd7d074cc4ee"><td class="memTemplParams" colspan="2">template&lt;typename Poly &gt; </td></tr>
<tr class="memitem:a426cbb1daa4c46b55454cd7d074cc4ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d18/a01284.html#a426cbb1daa4c46b55454cd7d074cc4ee">splitProducts</a> (const <a class="el" href="../../d8/dde/a03313.html">Constraint</a>&lt; Poly &gt; &amp;, bool=false)</td></tr>
<tr class="memdesc:a426cbb1daa4c46b55454cd7d074cc4ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the given constraint into a set of constraints which compare the factors of the factorization of the constraints considered polynomial.  <a href="../../dd/d18/a01284.html#a426cbb1daa4c46b55454cd7d074cc4ee">More...</a><br /></td></tr>
<tr class="separator:a426cbb1daa4c46b55454cd7d074cc4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7a1c2f59d46c78c2f27d187628f27f"><td class="memTemplParams" colspan="2">template&lt;typename Poly &gt; </td></tr>
<tr class="memitem:a1b7a1c2f59d46c78c2f27d187628f27f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d18/a01284.html#a1b7a1c2f59d46c78c2f27d187628f27f">splitSosDecompositions</a> (<a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;)</td></tr>
<tr class="separator:a1b7a1c2f59d46c78c2f27d187628f27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec672c155ac59a366bcbd8a0d8e0a77"><td class="memTemplParams" colspan="2">template&lt;typename Poly &gt; </td></tr>
<tr class="memitem:aeec672c155ac59a366bcbd8a0d8e0a77"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d18/a01284.html#aeec672c155ac59a366bcbd8a0d8e0a77">getSignCombinations</a> (const <a class="el" href="../../d8/dde/a03313.html">Constraint</a>&lt; Poly &gt; &amp;)</td></tr>
<tr class="memdesc:aeec672c155ac59a366bcbd8a0d8e0a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given constraint f_1*...*f_n ~ 0 this method computes all combinations of constraints f_1 ~_1 0 ...  <a href="../../dd/d18/a01284.html#aeec672c155ac59a366bcbd8a0d8e0a77">More...</a><br /></td></tr>
<tr class="separator:aeec672c155ac59a366bcbd8a0d8e0a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952eed60724c4ef35cc9d98fd2fce8a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d18/a01284.html#a952eed60724c4ef35cc9d98fd2fce8a6">getOddBitStrings</a> (size_t _length, std::vector&lt; std::bitset&lt; <a class="el" href="../../d6/d27/a01163.html#a3a52ec32f277859cdad53d1a104ae2c1">MAX_PRODUCT_SPLIT_NUMBER</a> &gt; &gt; &amp;_strings)</td></tr>
<tr class="separator:a952eed60724c4ef35cc9d98fd2fce8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac648479d5c9b53bbfd54159a8d14ebc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d18/a01284.html#ac648479d5c9b53bbfd54159a8d14ebc6">getEvenBitStrings</a> (size_t _length, std::vector&lt; std::bitset&lt; <a class="el" href="../../d6/d27/a01163.html#a3a52ec32f277859cdad53d1a104ae2c1">MAX_PRODUCT_SPLIT_NUMBER</a> &gt; &gt; &amp;_strings)</td></tr>
<tr class="separator:ac648479d5c9b53bbfd54159a8d14ebc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5208f4388e0f7701f364b4979c504259"><td class="memTemplParams" colspan="2">template&lt;typename Poly &gt; </td></tr>
<tr class="memitem:a5208f4388e0f7701f364b4979c504259"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d18/a01284.html#a5208f4388e0f7701f364b4979c504259">print</a> (<a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;_substitutionResults)</td></tr>
<tr class="memdesc:a5208f4388e0f7701f364b4979c504259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the given disjunction of conjunction of constraints.  <a href="../../dd/d18/a01284.html#a5208f4388e0f7701f364b4979c504259">More...</a><br /></td></tr>
<tr class="separator:a5208f4388e0f7701f364b4979c504259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9835196c0575d73cc4c055af5b5ac6e4"><td class="memTemplParams" colspan="2">template&lt;typename Poly &gt; </td></tr>
<tr class="memitem:a9835196c0575d73cc4c055af5b5ac6e4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d18/a01284.html#a9835196c0575d73cc4c055af5b5ac6e4">substitute</a> (const <a class="el" href="../../d8/dde/a03313.html">Constraint</a>&lt; Poly &gt; &amp;, const <a class="el" href="../../dc/d0c/a03801.html">Substitution</a>&lt; Poly &gt; &amp;, <a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;, bool _accordingPaper, <a class="el" href="../../d7/dc5/a01242.html#af041a077115bde1ac2e50ce08365b112">carl::Variables</a> &amp;, const <a class="el" href="../../dd/d18/a01284.html#a378ca4c5edeb478a7bc0b51f3ac12cf7">detail::EvalDoubleIntervalMap</a> &amp;)</td></tr>
<tr class="memdesc:a9835196c0575d73cc4c055af5b5ac6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a substitution to a constraint and stores the results in the given vector.  <a href="../../dd/d18/a01284.html#a9835196c0575d73cc4c055af5b5ac6e4">More...</a><br /></td></tr>
<tr class="separator:a9835196c0575d73cc4c055af5b5ac6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70891e67ad00c27c15c8a2134d83637"><td class="memTemplParams" colspan="2">template&lt;typename Poly &gt; </td></tr>
<tr class="memitem:ae70891e67ad00c27c15c8a2134d83637"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d18/a01284.html#ae70891e67ad00c27c15c8a2134d83637">substituteNormal</a> (const <a class="el" href="../../d8/dde/a03313.html">Constraint</a>&lt; Poly &gt; &amp;_cons, const <a class="el" href="../../dc/d0c/a03801.html">Substitution</a>&lt; Poly &gt; &amp;_subs, <a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;_result, bool _accordingPaper, <a class="el" href="../../d7/dc5/a01242.html#af041a077115bde1ac2e50ce08365b112">carl::Variables</a> &amp;_conflictingVariables, const <a class="el" href="../../dd/d18/a01284.html#a378ca4c5edeb478a7bc0b51f3ac12cf7">detail::EvalDoubleIntervalMap</a> &amp;_solutionSpace)</td></tr>
<tr class="memdesc:ae70891e67ad00c27c15c8a2134d83637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a substitution of a variable to a term, which is not minus infinity nor a to an square root expression plus an infinitesimal.  <a href="../../dd/d18/a01284.html#ae70891e67ad00c27c15c8a2134d83637">More...</a><br /></td></tr>
<tr class="separator:ae70891e67ad00c27c15c8a2134d83637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c675fdb9b0642312920cad8a5ff956"><td class="memTemplParams" colspan="2">template&lt;typename Poly &gt; </td></tr>
<tr class="memitem:ad8c675fdb9b0642312920cad8a5ff956"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d18/a01284.html#ad8c675fdb9b0642312920cad8a5ff956">substituteNormalSqrtEq</a> (const Poly &amp;_radicand, const Poly &amp;_q, const Poly &amp;_r, <a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;_result, bool _accordingPaper)</td></tr>
<tr class="memdesc:ad8c675fdb9b0642312920cad8a5ff956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sub-method of substituteNormalSqrt, where applying the substitution led to a term containing a square root.  <a href="../../dd/d18/a01284.html#ad8c675fdb9b0642312920cad8a5ff956">More...</a><br /></td></tr>
<tr class="separator:ad8c675fdb9b0642312920cad8a5ff956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4177bba61ec6f8dd5c6d8d1e84b51b"><td class="memTemplParams" colspan="2">template&lt;typename Poly &gt; </td></tr>
<tr class="memitem:a6a4177bba61ec6f8dd5c6d8d1e84b51b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d18/a01284.html#a6a4177bba61ec6f8dd5c6d8d1e84b51b">substituteNormalSqrtNeq</a> (const Poly &amp;_radicand, const Poly &amp;_q, const Poly &amp;_r, <a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;_result, bool _accordingPaper)</td></tr>
<tr class="memdesc:a6a4177bba61ec6f8dd5c6d8d1e84b51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sub-method of substituteNormalSqrt, where applying the substitution led to a term containing a square root.  <a href="../../dd/d18/a01284.html#a6a4177bba61ec6f8dd5c6d8d1e84b51b">More...</a><br /></td></tr>
<tr class="separator:a6a4177bba61ec6f8dd5c6d8d1e84b51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacea0226daf8b6d6ad72f34f2a975e70"><td class="memTemplParams" colspan="2">template&lt;typename Poly &gt; </td></tr>
<tr class="memitem:aacea0226daf8b6d6ad72f34f2a975e70"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d18/a01284.html#aacea0226daf8b6d6ad72f34f2a975e70">substituteNormalSqrtLess</a> (const Poly &amp;_radicand, const Poly &amp;_q, const Poly &amp;_r, const Poly &amp;_s, <a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;_result, bool _accordingPaper)</td></tr>
<tr class="memdesc:aacea0226daf8b6d6ad72f34f2a975e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sub-method of substituteNormalSqrt, where applying the substitution led to a term containing a square root.  <a href="../../dd/d18/a01284.html#aacea0226daf8b6d6ad72f34f2a975e70">More...</a><br /></td></tr>
<tr class="separator:aacea0226daf8b6d6ad72f34f2a975e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573d3d6e8622dbe4d1fbcfc067d7354f"><td class="memTemplParams" colspan="2">template&lt;typename Poly &gt; </td></tr>
<tr class="memitem:a573d3d6e8622dbe4d1fbcfc067d7354f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d18/a01284.html#a573d3d6e8622dbe4d1fbcfc067d7354f">substituteNormalSqrtLeq</a> (const Poly &amp;_radicand, const Poly &amp;_q, const Poly &amp;_r, const Poly &amp;_s, <a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;_result, bool _accordingPaper)</td></tr>
<tr class="memdesc:a573d3d6e8622dbe4d1fbcfc067d7354f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sub-method of substituteNormalSqrt, where applying the substitution led to a term containing a square root.  <a href="../../dd/d18/a01284.html#a573d3d6e8622dbe4d1fbcfc067d7354f">More...</a><br /></td></tr>
<tr class="separator:a573d3d6e8622dbe4d1fbcfc067d7354f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5adfc8ac0fe9b71fbc57a4a2306cea34"><td class="memTemplParams" colspan="2">template&lt;typename Poly &gt; </td></tr>
<tr class="memitem:a5adfc8ac0fe9b71fbc57a4a2306cea34"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d18/a01284.html#a5adfc8ac0fe9b71fbc57a4a2306cea34">substitutePlusEps</a> (const <a class="el" href="../../d8/dde/a03313.html">Constraint</a>&lt; Poly &gt; &amp;_cons, const <a class="el" href="../../dc/d0c/a03801.html">Substitution</a>&lt; Poly &gt; &amp;_subs, <a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;_result, bool _accordingPaper, <a class="el" href="../../d7/dc5/a01242.html#af041a077115bde1ac2e50ce08365b112">carl::Variables</a> &amp;_conflictingVariables, const <a class="el" href="../../dd/d18/a01284.html#a378ca4c5edeb478a7bc0b51f3ac12cf7">detail::EvalDoubleIntervalMap</a> &amp;_solutionSpace)</td></tr>
<tr class="memdesc:a5adfc8ac0fe9b71fbc57a4a2306cea34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given substitution to the given constraint, where the substitution is of the form [x -&gt; t+epsilon] with x as the variable and c and b polynomials in the real theory excluding x.  <a href="../../dd/d18/a01284.html#a5adfc8ac0fe9b71fbc57a4a2306cea34">More...</a><br /></td></tr>
<tr class="separator:a5adfc8ac0fe9b71fbc57a4a2306cea34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da1e8d93752d6f8845712c786699bb1"><td class="memTemplParams" colspan="2">template&lt;typename Poly &gt; </td></tr>
<tr class="memitem:a5da1e8d93752d6f8845712c786699bb1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d18/a01284.html#a5da1e8d93752d6f8845712c786699bb1">substituteEpsGradients</a> (const <a class="el" href="../../d8/dde/a03313.html">Constraint</a>&lt; Poly &gt; &amp;_cons, const <a class="el" href="../../dc/d0c/a03801.html">Substitution</a>&lt; Poly &gt; &amp;_subs, const <a class="el" href="../../d7/dc5/a01242.html#ae6425c371990fc6191cfb86852fc5d88">carl::Relation</a> _relation, <a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;, bool _accordingPaper, <a class="el" href="../../d7/dc5/a01242.html#af041a077115bde1ac2e50ce08365b112">carl::Variables</a> &amp;_conflictingVariables, const <a class="el" href="../../dd/d18/a01284.html#a378ca4c5edeb478a7bc0b51f3ac12cf7">detail::EvalDoubleIntervalMap</a> &amp;_solutionSpace)</td></tr>
<tr class="memdesc:a5da1e8d93752d6f8845712c786699bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sub-method of substituteEps, where one of the gradients in the point represented by the substitution must be negative if the given relation is less or positive if the given relation is greater.  <a href="../../dd/d18/a01284.html#a5da1e8d93752d6f8845712c786699bb1">More...</a><br /></td></tr>
<tr class="separator:a5da1e8d93752d6f8845712c786699bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363b48f8450ed8c7f6fc0d88ce1cc673"><td class="memTemplParams" colspan="2">template&lt;typename Poly &gt; </td></tr>
<tr class="memitem:a363b48f8450ed8c7f6fc0d88ce1cc673"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d18/a01284.html#a363b48f8450ed8c7f6fc0d88ce1cc673">substituteInf</a> (const <a class="el" href="../../d8/dde/a03313.html">Constraint</a>&lt; Poly &gt; &amp;_cons, const <a class="el" href="../../dc/d0c/a03801.html">Substitution</a>&lt; Poly &gt; &amp;_subs, <a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;_result, <a class="el" href="../../d7/dc5/a01242.html#af041a077115bde1ac2e50ce08365b112">carl::Variables</a> &amp;_conflictingVariables, const <a class="el" href="../../dd/d18/a01284.html#a378ca4c5edeb478a7bc0b51f3ac12cf7">detail::EvalDoubleIntervalMap</a> &amp;_solutionSpace)</td></tr>
<tr class="memdesc:a363b48f8450ed8c7f6fc0d88ce1cc673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given substitution to the given constraint, where the substitution is of the form [x -&gt; -infinity] with x as the variable and c and b polynomials in the real theory excluding x.  <a href="../../dd/d18/a01284.html#a363b48f8450ed8c7f6fc0d88ce1cc673">More...</a><br /></td></tr>
<tr class="separator:a363b48f8450ed8c7f6fc0d88ce1cc673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9dc78e8a372d1ee15d019da78b8d5f7"><td class="memTemplParams" colspan="2">template&lt;typename Poly &gt; </td></tr>
<tr class="memitem:ac9dc78e8a372d1ee15d019da78b8d5f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d18/a01284.html#ac9dc78e8a372d1ee15d019da78b8d5f7">substituteInfLessGreater</a> (const <a class="el" href="../../d8/dde/a03313.html">Constraint</a>&lt; Poly &gt; &amp;_cons, const <a class="el" href="../../dc/d0c/a03801.html">Substitution</a>&lt; Poly &gt; &amp;_subs, <a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;_result)</td></tr>
<tr class="memdesc:ac9dc78e8a372d1ee15d019da78b8d5f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given substitution to the given constraint, where the substitution is of the form [x -&gt; +/-infinity] with x as the variable and c and b polynomials in the real theory excluding x.  <a href="../../dd/d18/a01284.html#ac9dc78e8a372d1ee15d019da78b8d5f7">More...</a><br /></td></tr>
<tr class="separator:ac9dc78e8a372d1ee15d019da78b8d5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367228c8b2eb8fc89133fb649b4e10d5"><td class="memTemplParams" colspan="2">template&lt;typename Poly &gt; </td></tr>
<tr class="memitem:a367228c8b2eb8fc89133fb649b4e10d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d18/a01284.html#a367228c8b2eb8fc89133fb649b4e10d5">substituteTrivialCase</a> (const <a class="el" href="../../d8/dde/a03313.html">Constraint</a>&lt; Poly &gt; &amp;_cons, const <a class="el" href="../../dc/d0c/a03801.html">Substitution</a>&lt; Poly &gt; &amp;_subs, <a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;_result)</td></tr>
<tr class="memdesc:a367228c8b2eb8fc89133fb649b4e10d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deals with the case, that the left hand side of the constraint to substitute is a trivial polynomial in the variable to substitute.  <a href="../../dd/d18/a01284.html#a367228c8b2eb8fc89133fb649b4e10d5">More...</a><br /></td></tr>
<tr class="separator:a367228c8b2eb8fc89133fb649b4e10d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ca871170b469bf411647d10c102035"><td class="memTemplParams" colspan="2">template&lt;typename Poly &gt; </td></tr>
<tr class="memitem:a88ca871170b469bf411647d10c102035"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d18/a01284.html#a88ca871170b469bf411647d10c102035">substituteNotTrivialCase</a> (const <a class="el" href="../../d8/dde/a03313.html">Constraint</a>&lt; Poly &gt; &amp;, const <a class="el" href="../../dc/d0c/a03801.html">Substitution</a>&lt; Poly &gt; &amp;, <a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;)</td></tr>
<tr class="memdesc:a88ca871170b469bf411647d10c102035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deals with the case, that the left hand side of the constraint to substitute is not a trivial polynomial in the variable to substitute.  <a href="../../dd/d18/a01284.html#a88ca871170b469bf411647d10c102035">More...</a><br /></td></tr>
<tr class="separator:a88ca871170b469bf411647d10c102035"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ad68ae6436b21d9a31a10be6e7f3c0194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68ae6436b21d9a31a10be6e7f3c0194">&#9670;&nbsp;</a></span>DoubleInterval</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../dd/d18/a01284.html#ad68ae6436b21d9a31a10be6e7f3c0194">carl::vs::detail::DoubleInterval</a> = typedef <a class="el" href="../../d0/d80/a02281.html">carl::Interval</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d6/d27/a01163_source.html#l00051">51</a> of file <a class="el" href="../../d6/d27/a01163_source.html">substitute.h</a>.</p>

</div>
</div>
<a id="a378ca4c5edeb478a7bc0b51f3ac12cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a378ca4c5edeb478a7bc0b51f3ac12cf7">&#9670;&nbsp;</a></span>EvalDoubleIntervalMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../dd/d18/a01284.html#a378ca4c5edeb478a7bc0b51f3ac12cf7">carl::vs::detail::EvalDoubleIntervalMap</a> = typedef std::map&lt;<a class="el" href="../../d5/d88/a02141.html">carl::Variable</a>, <a class="el" href="../../dd/d18/a01284.html#ad68ae6436b21d9a31a10be6e7f3c0194">DoubleInterval</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d6/d27/a01163_source.html#l00052">52</a> of file <a class="el" href="../../d6/d27/a01163_source.html">substitute.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="afd089f7a6e94f345598ceeceb518cd95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd089f7a6e94f345598ceeceb518cd95">&#9670;&nbsp;</a></span>combine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class combineType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool carl::vs::detail::combine </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::vector&lt; combineType &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>_toCombine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; combineType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>_combination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_toCombine</td><td>The vectors to combine. </td></tr>
    <tr><td class="paramname">_combination</td><td>The resulting combination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false, if the upper limit in the number of combinations resulting by this method is exceeded. Note, that this hinders a combinatorial blow up. true, otherwise. </dd></dl>

</div>
</div>
<a id="ac648479d5c9b53bbfd54159a8d14ebc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac648479d5c9b53bbfd54159a8d14ebc6">&#9670;&nbsp;</a></span>getEvenBitStrings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void carl::vs::detail::getEvenBitStrings </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::bitset&lt; <a class="el" href="../../d6/d27/a01163.html#a3a52ec32f277859cdad53d1a104ae2c1">MAX_PRODUCT_SPLIT_NUMBER</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>_strings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_length</td><td>The maximal length of the bit strings with even parity to compute. </td></tr>
    <tr><td class="paramname">_strings</td><td>All bit strings of length less or equal the given length with even parity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a952eed60724c4ef35cc9d98fd2fce8a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952eed60724c4ef35cc9d98fd2fce8a6">&#9670;&nbsp;</a></span>getOddBitStrings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void carl::vs::detail::getOddBitStrings </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::bitset&lt; <a class="el" href="../../d6/d27/a01163.html#a3a52ec32f277859cdad53d1a104ae2c1">MAX_PRODUCT_SPLIT_NUMBER</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>_strings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_length</td><td>The maximal length of the bit strings with odd parity to compute. </td></tr>
    <tr><td class="paramname">_strings</td><td>All bit strings of length less or equal the given length with odd parity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeec672c155ac59a366bcbd8a0d8e0a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec672c155ac59a366bcbd8a0d8e0a77">&#9670;&nbsp;</a></span>getSignCombinations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Poly &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt;Poly&gt; carl::vs::detail::getSignCombinations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/dde/a03313.html">Constraint</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For a given constraint f_1*...*f_n ~ 0 this method computes all combinations of constraints f_1 ~_1 0 ... </p>
<p>f_n ~_n 0 such that </p><pre class="fragment">     f_1 ~_1 0 and ... and f_n ~_n 0   iff   f_1*...*f_n ~ 0 
</pre><p> holds. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_constraint</td><td>A pointer to the constraint to split this way. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting combinations. </dd></dl>

</div>
</div>
<a id="afbb94a47335dbab9c5e4e9885b35cb75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb94a47335dbab9c5e4e9885b35cb75">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Poly &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; carl::vs::detail::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d0c/a03801.html">Substitution</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d6/d27/a01163_source.html#l00046">46</a> of file <a class="el" href="../../d6/d27/a01163_source.html">substitute.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../dd/d18/a01284_afbb94a47335dbab9c5e4e9885b35cb75_cgraph.png" border="0" usemap="#add/d18/a01284_afbb94a47335dbab9c5e4e9885b35cb75_cgraph" alt=""/></div>
<map name="add/d18/a01284_afbb94a47335dbab9c5e4e9885b35cb75_cgraph" id="add/d18/a01284_afbb94a47335dbab9c5e4e9885b35cb75_cgraph">
<area shape="rect" title=" " alt="" coords="5,46,204,73"/>
<area shape="rect" href="../../dc/d0c/a03801.html#a8bd581b6f2d2b5531a74571ad28c2210" title=" " alt="" coords="252,5,452,47"/>
<area shape="rect" href="../../dc/d0c/a03801.html#a60c271674c8cf56f0d3ae012e9e439cb" title=" " alt="" coords="252,71,452,112"/>
</map>
</div>

</div>
</div>
<a id="a5208f4388e0f7701f364b4979c504259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5208f4388e0f7701f364b4979c504259">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Poly &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void carl::vs::detail::print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname"><em>_substitutionResults</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the given disjunction of conjunction of constraints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_substitutionResults</td><td>The disjunction of conjunction of constraints to print. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../dd/d18/a01284_a5208f4388e0f7701f364b4979c504259_icgraph.png" border="0" usemap="#add/d18/a01284_a5208f4388e0f7701f364b4979c504259_icgraph" alt=""/></div>
<map name="add/d18/a01284_a5208f4388e0f7701f364b4979c504259_icgraph" id="add/d18/a01284_a5208f4388e0f7701f364b4979c504259_icgraph">
<area shape="rect" title="Prints the given disjunction of conjunction of constraints." alt="" coords="184,5,336,32"/>
<area shape="rect" href="../../d7/dc5/a01242.html#acd790d0635ba60a442279c4a29f9fab1" title=" " alt="" coords="5,5,136,32"/>
</map>
</div>

</div>
</div>
<a id="aedf8e618e9cdafe85335859e4249c4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf8e618e9cdafe85335859e4249c4c6">&#9670;&nbsp;</a></span>simplify() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Poly &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void carl::vs::detail::simplify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplifies a disjunction of conjunctions of constraints by deleting consistent constraint and inconsistent conjunctions of constraints. </p>
<p>If a conjunction of only consistent constraints exists, the simplified disjunction contains one empty conjunction. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_toSimplify</td><td>The disjunction of conjunctions to simplify. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fa9d847d04b72d0594ba77c98ad7abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa9d847d04b72d0594ba77c98ad7abb">&#9670;&nbsp;</a></span>simplify() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Poly &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void carl::vs::detail::simplify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d7/dc5/a01242.html#af041a077115bde1ac2e50ce08365b112">carl::Variables</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d18/a01284.html#a378ca4c5edeb478a7bc0b51f3ac12cf7">detail::EvalDoubleIntervalMap</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplifies a disjunction of conjunctions of constraints by deleting consistent constraint and inconsistent conjunctions of constraints. </p>
<p>If a conjunction of only consistent constraints exists, the simplified disjunction contains one empty conjunction. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_toSimplify</td><td>The disjunction of conjunctions to simplify. </td></tr>
    <tr><td class="paramname">_conflictingVars</td><td></td></tr>
    <tr><td class="paramname">_solutionSpace</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf32e02e57654e0ef292a95560249b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf32e02e57654e0ef292a95560249b8c">&#9670;&nbsp;</a></span>splitProducts() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Poly &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool carl::vs::detail::splitProducts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits all constraints in the given disjunction of conjunctions of constraints having a non-trivial factorization into a set of constraints which compare the factors instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_toSimplify</td><td>The disjunction of conjunctions of the constraints to split. </td></tr>
    <tr><td class="paramname">_onlyNeq</td><td>A flag indicating that only constraints with the relation symbol != are split. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false, if the upper limit in the number of combinations resulting by this method is exceeded. Note, that this hinders a combinatorial blow up. true, otherwise. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../dd/d18/a01284_abf32e02e57654e0ef292a95560249b8c_icgraph.png" border="0" usemap="#add/d18/a01284_abf32e02e57654e0ef292a95560249b8c_icgraph" alt=""/></div>
<map name="add/d18/a01284_abf32e02e57654e0ef292a95560249b8c_icgraph" id="add/d18/a01284_abf32e02e57654e0ef292a95560249b8c_icgraph">
<area shape="rect" title="Splits all constraints in the given disjunction of conjunctions of constraints having a non&#45;trivial f..." alt="" coords="564,13,771,39"/>
<area shape="rect" href="../../d5/da7/a01283.html#a3f6a9afd6f9d243835d6cca68897fb19" title="Simplifies the case distinction in place." alt="" coords="387,5,516,47"/>
<area shape="rect" href="../../d5/da7/a01283.html#a2e8b6620391ce135b0c81929328fbbe2" title="Applies a substitution to a constraint." alt="" coords="196,13,339,39"/>
<area shape="rect" href="../../d5/da7/a01283.html#ad5b4aa3676afed7d74cc6829a9fa4d7f" title="Applies a substitution to a variable comparison." alt="" coords="5,13,148,39"/>
</map>
</div>

</div>
</div>
<a id="a426cbb1daa4c46b55454cd7d074cc4ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426cbb1daa4c46b55454cd7d074cc4ee">&#9670;&nbsp;</a></span>splitProducts() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Poly &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt;Poly&gt; carl::vs::detail::splitProducts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/dde/a03313.html">Constraint</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits the given constraint into a set of constraints which compare the factors of the factorization of the constraints considered polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_constraint</td><td>A pointer to the constraint to split. </td></tr>
    <tr><td class="paramname">_onlyNeq</td><td>A flag indicating that only constraints with the relation symbol != are split. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting disjunction of conjunctions of constraints, which is semantically equivalent to the given constraint. </dd></dl>

</div>
</div>
<a id="a28068591855e49e45ab5eca426fef5c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28068591855e49e45ab5eca426fef5c6">&#9670;&nbsp;</a></span>splitProducts() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Poly &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool carl::vs::detail::splitProducts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/da7/a01283.html#a947162a487c857f6f7b2b94d7b1ab627">ConstraintConjunction</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; const <a class="el" href="../../d8/dde/a03313.html">Constraint</a>&lt; Poly &gt;, <a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt;&gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits all constraints in the given conjunction of constraints having a non-trivial factorization into a set of constraints which compare the factors instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_toSimplify</td><td>The conjunction of the constraints to split. </td></tr>
    <tr><td class="paramname">_result</td><td>The result, being a disjunction of conjunctions of constraints. </td></tr>
    <tr><td class="paramname">_onlyNeq</td><td>A flag indicating that only constraints with the relation symbol != are split. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false, if the upper limit in the number of combinations resulting by this method is exceeded. Note, that this hinders a combinatorial blow up. true, otherwise. </dd></dl>

</div>
</div>
<a id="a1b7a1c2f59d46c78c2f27d187628f27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7a1c2f59d46c78c2f27d187628f27f">&#9670;&nbsp;</a></span>splitSosDecompositions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Poly &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void carl::vs::detail::splitSosDecompositions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../dd/d18/a01284_a1b7a1c2f59d46c78c2f27d187628f27f_icgraph.png" border="0" usemap="#add/d18/a01284_a1b7a1c2f59d46c78c2f27d187628f27f_icgraph" alt=""/></div>
<map name="add/d18/a01284_a1b7a1c2f59d46c78c2f27d187628f27f_icgraph" id="add/d18/a01284_a1b7a1c2f59d46c78c2f27d187628f27f_icgraph">
<area shape="rect" title=" " alt="" coords="564,5,737,47"/>
<area shape="rect" href="../../d5/da7/a01283.html#a3f6a9afd6f9d243835d6cca68897fb19" title="Simplifies the case distinction in place." alt="" coords="387,5,516,47"/>
<area shape="rect" href="../../d5/da7/a01283.html#a2e8b6620391ce135b0c81929328fbbe2" title="Applies a substitution to a constraint." alt="" coords="196,13,339,39"/>
<area shape="rect" href="../../d5/da7/a01283.html#ad5b4aa3676afed7d74cc6829a9fa4d7f" title="Applies a substitution to a variable comparison." alt="" coords="5,13,148,39"/>
</map>
</div>

</div>
</div>
<a id="a9835196c0575d73cc4c055af5b5ac6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9835196c0575d73cc4c055af5b5ac6e4">&#9670;&nbsp;</a></span>substitute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Poly &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool carl::vs::detail::substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/dde/a03313.html">Constraint</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d0c/a03801.html">Substitution</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_accordingPaper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d7/dc5/a01242.html#af041a077115bde1ac2e50ce08365b112">carl::Variables</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d18/a01284.html#a378ca4c5edeb478a7bc0b51f3ac12cf7">detail::EvalDoubleIntervalMap</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a substitution to a constraint and stores the results in the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_cons</td><td>The constraint to substitute in. </td></tr>
    <tr><td class="paramname">_subs</td><td>The substitution to apply. </td></tr>
    <tr><td class="paramname">_result</td><td>The vector, in which to store the results of this substitution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false, if the upper limit in the number of combinations in the result of the substitution is exceeded. Note, that this hinders a combinatorial blow up. true, otherwise. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../dd/d18/a01284_a9835196c0575d73cc4c055af5b5ac6e4_icgraph.png" border="0" usemap="#add/d18/a01284_a9835196c0575d73cc4c055af5b5ac6e4_icgraph" alt=""/></div>
<map name="add/d18/a01284_a9835196c0575d73cc4c055af5b5ac6e4_icgraph" id="add/d18/a01284_a9835196c0575d73cc4c055af5b5ac6e4_icgraph">
<area shape="rect" title="Applies a substitution to a constraint and stores the results in the given vector." alt="" coords="387,5,573,32"/>
<area shape="rect" href="../../d5/da7/a01283.html#a2e8b6620391ce135b0c81929328fbbe2" title="Applies a substitution to a constraint." alt="" coords="196,5,339,32"/>
<area shape="rect" href="../../d5/da7/a01283.html#ad5b4aa3676afed7d74cc6829a9fa4d7f" title="Applies a substitution to a variable comparison." alt="" coords="5,5,148,32"/>
</map>
</div>

</div>
</div>
<a id="a5da1e8d93752d6f8845712c786699bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da1e8d93752d6f8845712c786699bb1">&#9670;&nbsp;</a></span>substituteEpsGradients()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Poly &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool carl::vs::detail::substituteEpsGradients </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/dde/a03313.html">Constraint</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname"><em>_cons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d0c/a03801.html">Substitution</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname"><em>_subs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/dc5/a01242.html#ae6425c371990fc6191cfb86852fc5d88">carl::Relation</a>&#160;</td>
          <td class="paramname"><em>_relation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_accordingPaper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d7/dc5/a01242.html#af041a077115bde1ac2e50ce08365b112">carl::Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>_conflictingVariables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d18/a01284.html#a378ca4c5edeb478a7bc0b51f3ac12cf7">detail::EvalDoubleIntervalMap</a> &amp;&#160;</td>
          <td class="paramname"><em>_solutionSpace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sub-method of substituteEps, where one of the gradients in the point represented by the substitution must be negative if the given relation is less or positive if the given relation is greater. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_cons</td><td>The constraint to substitute in. </td></tr>
    <tr><td class="paramname">_subs</td><td>The substitution to apply. </td></tr>
    <tr><td class="paramname">_relation</td><td>The relation symbol, deciding whether the substitution result must be negative or positive. </td></tr>
    <tr><td class="paramname">_result</td><td>The vector, in which to store the results of this substitution. It is semantically a disjunction of conjunctions of constraints. </td></tr>
    <tr><td class="paramname">_accordingPaper</td><td>A flag that indicates whether to apply the virtual substitution rules according to the paper "Quantifier elimination
                       for real algebra - the quadratic case and beyond." by Volker Weispfenning (true) or in an adapted way which omits a higher degree in the result by splitting the result in more cases (false). </td></tr>
    <tr><td class="paramname">_conflictingVariables</td><td>If a conflict with the given solution space occurs, the variables being part of this conflict are stored in this container. </td></tr>
    <tr><td class="paramname">_solutionSpace</td><td>The solution space in form of double intervals of the variables occurring in the given constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a363b48f8450ed8c7f6fc0d88ce1cc673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a363b48f8450ed8c7f6fc0d88ce1cc673">&#9670;&nbsp;</a></span>substituteInf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Poly &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void carl::vs::detail::substituteInf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/dde/a03313.html">Constraint</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname"><em>_cons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d0c/a03801.html">Substitution</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname"><em>_subs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname"><em>_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d7/dc5/a01242.html#af041a077115bde1ac2e50ce08365b112">carl::Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>_conflictingVariables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d18/a01284.html#a378ca4c5edeb478a7bc0b51f3ac12cf7">detail::EvalDoubleIntervalMap</a> &amp;&#160;</td>
          <td class="paramname"><em>_solutionSpace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the given substitution to the given constraint, where the substitution is of the form [x -&gt; -infinity] with x as the variable and c and b polynomials in the real theory excluding x. </p>
<p>The constraint is of the form "f(x) \rho 0" with \rho element of {=,!=,&lt;,&gt;,&lt;=,&gt;=} and k as the maximum degree of x in f. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_cons</td><td>The constraint to substitute in. </td></tr>
    <tr><td class="paramname">_subs</td><td>The substitution to apply. </td></tr>
    <tr><td class="paramname">_result</td><td>The vector, in which to store the results of this substitution. It is semantically a disjunction of conjunctions of constraints. </td></tr>
    <tr><td class="paramname">_conflictingVariables</td><td>If a conflict with the given solution space occurs, the variables being part of this conflict are stored in this container. </td></tr>
    <tr><td class="paramname">_solutionSpace</td><td>The solution space in form of double intervals of the variables occurring in the given constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9dc78e8a372d1ee15d019da78b8d5f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9dc78e8a372d1ee15d019da78b8d5f7">&#9670;&nbsp;</a></span>substituteInfLessGreater()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Poly &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void carl::vs::detail::substituteInfLessGreater </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/dde/a03313.html">Constraint</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname"><em>_cons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d0c/a03801.html">Substitution</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname"><em>_subs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname"><em>_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the given substitution to the given constraint, where the substitution is of the form [x -&gt; +/-infinity] with x as the variable and c and b polynomials in the real theory excluding x. </p>
<p>The constraint is of the form "a*x^2+bx+c \rho 0", where \rho is less or greater. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_cons</td><td>The constraint to substitute in. </td></tr>
    <tr><td class="paramname">_subs</td><td>The substitution to apply. </td></tr>
    <tr><td class="paramname">_result</td><td>The vector, in which to store the results of this substitution. It is semantically a disjunction of conjunctions of constraints. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae70891e67ad00c27c15c8a2134d83637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70891e67ad00c27c15c8a2134d83637">&#9670;&nbsp;</a></span>substituteNormal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Poly &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool carl::vs::detail::substituteNormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/dde/a03313.html">Constraint</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname"><em>_cons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d0c/a03801.html">Substitution</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname"><em>_subs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname"><em>_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_accordingPaper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d7/dc5/a01242.html#af041a077115bde1ac2e50ce08365b112">carl::Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>_conflictingVariables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d18/a01284.html#a378ca4c5edeb478a7bc0b51f3ac12cf7">detail::EvalDoubleIntervalMap</a> &amp;&#160;</td>
          <td class="paramname"><em>_solutionSpace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a substitution of a variable to a term, which is not minus infinity nor a to an square root expression plus an infinitesimal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_cons</td><td>The constraint to substitute in. </td></tr>
    <tr><td class="paramname">_subs</td><td>The substitution to apply. </td></tr>
    <tr><td class="paramname">_result</td><td>The vector, in which to store the results of this substitution. It is semantically a disjunction of conjunctions of constraints. </td></tr>
    <tr><td class="paramname">_accordingPaper</td><td>A flag that indicates whether to apply the virtual substitution rules according to the paper "Quantifier elimination
                       for real algebra - the quadratic case and beyond." by Volker Weispfenning (true) or in an adapted way which omits a higher degree in the result by splitting the result in more cases (false). </td></tr>
    <tr><td class="paramname">_conflictingVariables</td><td>If a conflict with the given solution space occurs, the variables being part of this conflict are stored in this container. </td></tr>
    <tr><td class="paramname">_solutionSpace</td><td>The solution space in form of double intervals of the variables occurring in the given constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8c675fdb9b0642312920cad8a5ff956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c675fdb9b0642312920cad8a5ff956">&#9670;&nbsp;</a></span>substituteNormalSqrtEq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Poly &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool carl::vs::detail::substituteNormalSqrtEq </td>
          <td>(</td>
          <td class="paramtype">const Poly &amp;&#160;</td>
          <td class="paramname"><em>_radicand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Poly &amp;&#160;</td>
          <td class="paramname"><em>_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Poly &amp;&#160;</td>
          <td class="paramname"><em>_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname"><em>_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_accordingPaper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sub-method of substituteNormalSqrt, where applying the substitution led to a term containing a square root. </p>
<p>The relation symbol of the constraint to substitute is "=". </p><pre class="fragment">                         (_q+_r*sqrt(_radicand))
</pre><p> The term then looks like: ---------------&mdash; _s</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_radicand</td><td>The radicand of the square root. </td></tr>
    <tr><td class="paramname">_q</td><td>The summand not containing the square root. </td></tr>
    <tr><td class="paramname">_r</td><td>The coefficient of the radicand. </td></tr>
    <tr><td class="paramname">_result</td><td>The vector, in which to store the results of this substitution. It is semantically a disjunction of conjunctions of constraints. </td></tr>
    <tr><td class="paramname">_accordingPaper</td><td>A flag that indicates whether to apply the virtual substitution rules according to the paper "Quantifier elimination
                       for real algebra - the quadratic case and beyond." by Volker Weispfenning (true) or in an adapted way which omits a higher degree in the result by splitting the result in more cases (false). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a573d3d6e8622dbe4d1fbcfc067d7354f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573d3d6e8622dbe4d1fbcfc067d7354f">&#9670;&nbsp;</a></span>substituteNormalSqrtLeq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Poly &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool carl::vs::detail::substituteNormalSqrtLeq </td>
          <td>(</td>
          <td class="paramtype">const Poly &amp;&#160;</td>
          <td class="paramname"><em>_radicand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Poly &amp;&#160;</td>
          <td class="paramname"><em>_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Poly &amp;&#160;</td>
          <td class="paramname"><em>_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Poly &amp;&#160;</td>
          <td class="paramname"><em>_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname"><em>_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_accordingPaper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sub-method of substituteNormalSqrt, where applying the substitution led to a term containing a square root. </p>
<p>The relation symbol of the constraint to substitute is less or equal. </p><pre class="fragment">                         (_q+_r*sqrt(_radicand))
</pre><p> The term then looks like: -------------------&mdash; _s</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_radicand</td><td>The radicand of the square root. </td></tr>
    <tr><td class="paramname">_q</td><td>The summand not containing the square root. </td></tr>
    <tr><td class="paramname">_r</td><td>The coefficient of the radicand. </td></tr>
    <tr><td class="paramname">_s</td><td>The denominator of the expression containing the square root. </td></tr>
    <tr><td class="paramname">_result</td><td>The vector, in which to store the results of this substitution. It is semantically a disjunction of conjunctions of constraints. </td></tr>
    <tr><td class="paramname">_accordingPaper</td><td>A flag that indicates whether to apply the virtual substitution rules according to the paper "Quantifier elimination
                       for real algebra - the quadratic case and beyond." by Volker Weispfenning (true) or in an adapted way which omits a higher degree in the result by splitting the result in more cases (false). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacea0226daf8b6d6ad72f34f2a975e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacea0226daf8b6d6ad72f34f2a975e70">&#9670;&nbsp;</a></span>substituteNormalSqrtLess()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Poly &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool carl::vs::detail::substituteNormalSqrtLess </td>
          <td>(</td>
          <td class="paramtype">const Poly &amp;&#160;</td>
          <td class="paramname"><em>_radicand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Poly &amp;&#160;</td>
          <td class="paramname"><em>_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Poly &amp;&#160;</td>
          <td class="paramname"><em>_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Poly &amp;&#160;</td>
          <td class="paramname"><em>_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname"><em>_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_accordingPaper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sub-method of substituteNormalSqrt, where applying the substitution led to a term containing a square root. </p>
<p>The relation symbol of the constraint to substitute is less. </p><pre class="fragment">                         (_q+_r*sqrt(_radicand))
</pre><p> The term then looks like: -------------------&mdash; _s</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_radicand</td><td>The radicand of the square root. </td></tr>
    <tr><td class="paramname">_q</td><td>The summand not containing the square root. </td></tr>
    <tr><td class="paramname">_r</td><td>The coefficient of the radicand. </td></tr>
    <tr><td class="paramname">_s</td><td>The denominator of the expression containing the square root. </td></tr>
    <tr><td class="paramname">_result</td><td>The vector, in which to store the results of this substitution. It is semantically a disjunction of conjunctions of constraints. </td></tr>
    <tr><td class="paramname">_accordingPaper</td><td>A flag that indicates whether to apply the virtual substitution rules according to the paper "Quantifier elimination
                       for real algebra - the quadratic case and beyond." by Volker Weispfenning (true) or in an adapted way which omits a higher degree in the result by splitting the result in more cases (false). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a4177bba61ec6f8dd5c6d8d1e84b51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a4177bba61ec6f8dd5c6d8d1e84b51b">&#9670;&nbsp;</a></span>substituteNormalSqrtNeq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Poly &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool carl::vs::detail::substituteNormalSqrtNeq </td>
          <td>(</td>
          <td class="paramtype">const Poly &amp;&#160;</td>
          <td class="paramname"><em>_radicand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Poly &amp;&#160;</td>
          <td class="paramname"><em>_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Poly &amp;&#160;</td>
          <td class="paramname"><em>_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname"><em>_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_accordingPaper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sub-method of substituteNormalSqrt, where applying the substitution led to a term containing a square root. </p>
<p>The relation symbol of the constraint to substitute is "!=". </p><pre class="fragment">                         (_q+_r*sqrt(_radicand))
</pre><p> The term then looks like: --------------------&mdash; _s</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_radicand</td><td>The radicand of the square root. </td></tr>
    <tr><td class="paramname">_q</td><td>The summand not containing the square root. </td></tr>
    <tr><td class="paramname">_r</td><td>The coefficient of the radicand. </td></tr>
    <tr><td class="paramname">_result</td><td>The vector, in which to store the results of this substitution. It is semantically a disjunction of conjunctions of constraints. </td></tr>
    <tr><td class="paramname">_accordingPaper</td><td>A flag that indicates whether to apply the virtual substitution rules according to the paper "Quantifier elimination
                       for real algebra - the quadratic case and beyond." by Volker Weispfenning (true) or in an adapted way which omits a higher degree in the result by splitting the result in more cases (false). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88ca871170b469bf411647d10c102035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ca871170b469bf411647d10c102035">&#9670;&nbsp;</a></span>substituteNotTrivialCase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Poly &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void carl::vs::detail::substituteNotTrivialCase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/dde/a03313.html">Constraint</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d0c/a03801.html">Substitution</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deals with the case, that the left hand side of the constraint to substitute is not a trivial polynomial in the variable to substitute. </p>
<p>The constraints left hand side then should looks like: ax^2+bx+c </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_cons</td><td>The constraint to substitute in. </td></tr>
    <tr><td class="paramname">_subs</td><td>The substitution to apply. </td></tr>
    <tr><td class="paramname">_result</td><td>The vector, in which to store the results of this substitution. It is semantically a disjunction of conjunctions of constraints. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5adfc8ac0fe9b71fbc57a4a2306cea34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5adfc8ac0fe9b71fbc57a4a2306cea34">&#9670;&nbsp;</a></span>substitutePlusEps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Poly &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool carl::vs::detail::substitutePlusEps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/dde/a03313.html">Constraint</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname"><em>_cons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d0c/a03801.html">Substitution</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname"><em>_subs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname"><em>_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_accordingPaper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d7/dc5/a01242.html#af041a077115bde1ac2e50ce08365b112">carl::Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>_conflictingVariables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d18/a01284.html#a378ca4c5edeb478a7bc0b51f3ac12cf7">detail::EvalDoubleIntervalMap</a> &amp;&#160;</td>
          <td class="paramname"><em>_solutionSpace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the given substitution to the given constraint, where the substitution is of the form [x -&gt; t+epsilon] with x as the variable and c and b polynomials in the real theory excluding x. </p>
<p>The constraint is of the form "f(x) \rho 0" with \rho element of {=,!=,&lt;,&gt;,&lt;=,&gt;=} and k as the maximum degree of x in f.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_cons</td><td>The constraint to substitute in. </td></tr>
    <tr><td class="paramname">_subs</td><td>The substitution to apply. </td></tr>
    <tr><td class="paramname">_result</td><td>The vector, in which to store the results of this substitution. It is semantically a disjunction of conjunctions of constraints. </td></tr>
    <tr><td class="paramname">_accordingPaper</td><td>A flag that indicates whether to apply the virtual substitution rules according to the paper "Quantifier elimination
                       for real algebra - the quadratic case and beyond." by Volker Weispfenning (true) or in an adapted way which omits a higher degree in the result by splitting the result in more cases (false). </td></tr>
    <tr><td class="paramname">_conflictingVariables</td><td>If a conflict with the given solution space occurs, the variables being part of this conflict are stored in this container. </td></tr>
    <tr><td class="paramname">_solutionSpace</td><td>The solution space in form of double intervals of the variables occurring in the given constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a367228c8b2eb8fc89133fb649b4e10d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367228c8b2eb8fc89133fb649b4e10d5">&#9670;&nbsp;</a></span>substituteTrivialCase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Poly &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void carl::vs::detail::substituteTrivialCase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/dde/a03313.html">Constraint</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname"><em>_cons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d0c/a03801.html">Substitution</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname"><em>_subs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/da7/a01283.html#aac0a1d35ac0b5170e7fc25bb2d099d63">CaseDistinction</a>&lt; Poly &gt; &amp;&#160;</td>
          <td class="paramname"><em>_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deals with the case, that the left hand side of the constraint to substitute is a trivial polynomial in the variable to substitute. </p>
<p>The constraints left hand side then should look like: ax^2+bx+c </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_cons</td><td>The constraint to substitute in. </td></tr>
    <tr><td class="paramname">_subs</td><td>The substitution to apply. </td></tr>
    <tr><td class="paramname">_result</td><td>The vector, in which to store the results of this substitution. It is semantically a disjunction of conjunctions of constraints. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d7/dc5/a01242.html">carl</a></li><li class="navelem"><a class="el" href="../../d5/da7/a01283.html">vs</a></li><li class="navelem"><a class="el" href="../../dd/d18/a01284.html">detail</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
