<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SMT-RAT: Using SMT-RAT</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../logo_smtrat.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SMT-RAT
   &#160;<span id="projectnumber">24.02</span>
   </div>
   <div id="projectbrief">Toolbox for Strategic and Parallel Satisfiability-Modulo-Theories Solving</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('dc/dad/md__builds_ths_smt_smtrat_doc_markdown_07_using_smtrat.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Using SMT-RAT </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>SMT-RAT can be used in two ways, either as a standalone solver or as a C++ library within some other software.</p>
<h1><a class="anchor" id="autotoc_md23"></a>
Standalone solver</h1>
<p>Before actually compiling SMT-RAT into a binary, an appropriate strategy should be selected. While a number of strategies are available, it sometimes makes sense to craft a strategy for the specific problem at hand. Please refer to <a class="el" href="../../d5/dc7/strategies.html">Strategies</a> on how to create strategies. To select a strategy use <code>ccmake</code> to set the <code>SMTRAT_Strategy</code> variable accordingly and then build the solver binary using <code>make smtrat-shared</code>. Use <code>./smtrat-shared --strategy</code> to check whether the desired strategy is used.</p>
<p>The solver binary can now be used to solve input in the <code>smt2</code> format, either given as a filename or on standard input: </p><pre class="fragment">./smtrat-shared &lt;input file&gt;
cat &lt;input file&gt; | ./smtrat-shared -
</pre><p> Note that the solver binary can perform many other tasks as well that we discuss below. Some of these are enabled (or disabled) by a set of <code>cmake</code> options of the form <code>CLI_ENABLE_*</code> and the currently available ones can be obtained as follows: </p><pre class="fragment">$ ./smtrat-shared --help
Usage: ./smtrat-shared [options] input-file

Core settings:
  --help                                show help
  --info                                show some basic information about this 
                                        binary
  --version                             show the version of this binary
  --settings                            show the settings that are used
  --cmake-options                       show the cmake options during 
                                        compilation
  --strategy                            show the configured strategy
  --license                             show the license
  -c [ --config ] arg                   load config from the given config file

Solver settings:
  --preprocess                          only preprocess the input
  --pp-output-file arg                  store the preprocessed input to this 
                                        file
  --to-cnf-dimacs                       transform formula to cnf as dimacs
  --to-cnf-smtlib                       transform formula to cnf as smtlib
  --print-model                         print a model if the input is 
                                        satisfiable
  --print-all-models                    print all models of the input

Validation settings:
  --validation.export-smtlib            store validation formulas to smtlib 
                                        file
  --validation.smtlib-filename arg (=validation.smt2)
                                        filename of smtlib output
  --validation.channel arg              add a channel to be considered


Module settings:
  --module.parameter arg                add a parameter for modules (key=value)

Parser settings:
  --dimacs                              parse input file as dimacs file
  --opb                                 parse input file as OPB file
  --input-file arg                      path of the input file
  --disable-uf-flattening               disable flattening of nested 
                                        uninterpreted functions
  --disable-theory                      disable theory construction

Analysis settings:
  --analyze.enabled                     enable formula analyzer
  --analyze.projections arg (=none)     which CAD projections to analyze (all, 
                                        collins, hong, mccallum, 
                                        mccallum_partial, lazard, brown, none)

CAD Preprocessor settings:
  --cad.pp.no-elimination               disable variable elimination
  --cad.pp.no-resultants                disable resultant rule
</pre><h2><a class="anchor" id="formula-analysis"></a>
Formula analysis</h2>
<p>One sometimes wants to only obtain certain information about the given formula, usually for statistical purposes. SMT-RAT exposes a formula analyzer that gives a number of properties of the formula. </p><pre class="fragment">$ ./smtrat-shared --analyze.enabled &lt;input file&gt;
</pre> <h2><a class="anchor" id="preprocessing"></a>
Preprocessing</h2>
<p>While many SMT-RAT strategies employ certain preprocessing techniques, it is sometimes convenient to apply this preprocessing ahead of time, for example to normalize the inputs. The result is either printed or written to an output file if <code>--pp-output-file</code> is given. </p><pre class="fragment">$ ./smtrat-shared --preprocess --pp-output-file &lt;output file&gt; &lt;input file&gt;
</pre><h2><a class="anchor" id="quantifier-elimination"></a>
Quantifier elimination</h2>
<p>Instead of regular SMT solving, SMT-RAT can also perform quantifier elimination tasks. This feature is disabled in the default build of SMT-RAT and can be enabled by turning on the build option <code>CLI_ENABLE_QUANTIFIER_ELIMINATION</code>. This technique is used when the SMTLIB file contains a formula with quantifiers and a <code>(apply qe)</code> command like in z3. SMT-RAT supports different quantifier elimination methods. The default is based on cylindrical algebraic coverings and can handle non-linear arithmetic, arbitrary quantifiers and Boolean structure (NRA). For eliminating existential quantifiers from conjunctions of linear constraints, we provide the Fourier-Motzkin (FM) and the fmplex method. The method can be set either by passing the option <code>--module.parameter qe-method=&lt;covering/fm/fmplex&gt;</code> in the command line, or in the SMT-lib file via <code>(set-option :qe-method &lt;covering/fm/fmplex&gt;)</code>.</p>
<h2><a class="anchor" id="dimacs-solving"></a>
DIMACS solving</h2>
<p>For purely propositional formulae (i.e. SAT solving) one usually uses the (much more compact) DIMACS format instead of SMT-LIB. Note that SMT-RAT still uses the configured strategy to solve the given input instead of only a SAT solver, allowing to use custom preprocessing techniques. </p><pre class="fragment">$ ./smtrat-shared --dimacs &lt;input file&gt;
</pre><h2><a class="anchor" id="pb-solving"></a>
Pseudo-Boolean solving</h2>
<p>Another interesting solving task is concerned with pseudo-Boolean formulae where Boolean variables are used in arithmetic constraints (and implicitly considered as being integers over just zero and one). A special input format called OPB exists (rather similar to DIMACS) that can be read and solved with a strategy based on <a class="el" href="../../d0/de3/citelist.html#CITEREF_Grobelna2017">[13]</a> as follows: </p><pre class="fragment">$ ./smtrat-shared --opb &lt;input file&gt;
</pre> <h2><a class="anchor" id="autotoc_md24"></a>
Optimization</h2>
<p>For many applications, one wants not only some feasible solution but rather an optimal solution with respect to some objective function. This is used when the SMTLIB file contains one or more <code>(minimize)</code> or <code>(maximize)</code> commands with semantics similar to what is described for <a href="https://rise4fun.com/Z3/tutorialcontent/optimization">z3</a>.</p>
<h1><a class="anchor" id="autotoc_md25"></a>
Embedding in other software</h1>
<p>Instead of using SMT-RAT as a standalone solver, it can also be embedded in other software.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
Interface</h2>
<p>The easiest way is to embed a certain strategy.</p>
<p>If for instance the SMT solver based on the strategy of <code>RatOne</code> shall be used (we can also choose any self-composed strategy here), we can create it as follows:</p>
<div class="fragment"><div class="line">smtrat::RatOne yourSolver = smtrat::RatOne();</div>
</div><!-- fragment --><p>As all strategies are derived from the Manager class, we can thus use the Manager interface. The most important methods are the following:</p>
<ul>
<li><code>bool inform( const FormulaT&amp; )</code> Informs the solver about a constraint, wrapped by the given formula. Optimally, the solver should be informed about all constraints, which it will receive eventually, before any of them is added as part of a formula with the interface <code>add(..)</code>. The method returns <code>false</code> if it is easy to decide (for any module used in this solver), whether the constraint itself is inconsistent.</li>
<li><code>bool add( const FormulaT&amp; )</code> Adds the given formula to the conjunction of formulas, which will be considered for the next satisfiability check. The method returns <code>false</code>, if it is easy to decide whether the just added formula is not satisfiable in the context of the already added formulas. Note, that only a very superficial and cheap satisfiability check is performed and mainly depends on solutions of previous consistency checks. In the most cases this method returns <code>true</code>, but in the case it does not the corresponding infeasible subset(s) can be obtained by <code>infeasibleSubsets()</code>.</li>
<li><code>Answer check( bool )</code> This method checks the so far added formulas for satisfiability. If, for instance we extend an SMT solver by a theory solver composed with SMT-RAT, these formulas are only constraints. The answer can either be <code>SAT</code>, if satisfiability has been detected, or <code>UNSAT</code>, if the formulas are not satisfiable, and <code>UNKNOWN</code>, if the composition cannot give a conclusive answer. If the answer has been <code>SAT</code>, we get the model, satisfying the conjunction of the given formulas, using <code>model()</code> and, if it has been <code>UNSAT</code>, we can obtain infeasible subsets by <code>infeasibleSubsets()</code>. If the answer is <code>UNKNOWN</code>, the composed solver is either incomplete (which highly depends on the strategy but for QF_NRA it is actually always possible to define a strategy for a complete SMT-RAT solver) or it communicates lemmas/tautologies, which can be obtained applying <code>lemmas()</code>. If we embed, e.g., a theory solver composed with SMT-RAT into an SMT solver, these lemmas can be used in its sat solving process in the same way as infeasible subsets are used. The strategy of an SMT solver composed with SMT-RAT has to involve a <code>SATModule</code> before any theory module is used (It is possible to define a strategy using conditions in a way, that we achieve an SMT solver, even if for some cases no <code>SATModule</code> is involved before a theory module is applied.) and, therefore, the SMT solver never communicates these lemmas as they are already processed by the <code>SATModule</code>. A better explanation on the modules and the strategy can be found in <a href="../../#architecture">system architecture</a>. If the Boolean argument of the function <code>check</code> is <code>false</code>, the composed solver is allowed to omit hard obstacles during solving at the cost of returning <code>UNKNOWN</code> in more cases.</li>
<li><code>void push()</code> Pushes a backtrack point to the stack of backtrack points.</li>
<li><code>bool pop()</code> Pops a backtrack point from the stack of backtrack points and undoes everything which has been done after adding that backtrack point. It returns <code>false</code> if no backtrack point is on the stack. Note, that SMT-RAT supports incrementality, that means, that by removing everything which has been done after adding a backtrack point, we mean, that all intermediate solving results which only depend on the formulas to remove are deleted. It is highly recommended not to remove anything, which is going to be added directly afterwards.</li>
<li><code>const std::vector&lt;FormulasT&gt;&amp; infeasibleSubsets() const</code> Returns one or more reasons for the unsatisfiability of the considered conjunction of formulas of this SMT-RAT composition. A reason is an infeasible subset of the sub-formulas of this conjunction.</li>
<li><code>const Model&amp; model() const</code> Returns an assignment of the variables, which occur in the so far added formulas, to values of their domains, such that it satisfies the conjunction of these formulas. Note, that an assignment is only provided if the conjunction of so far added formulas is satisfiable. Furthermore, when solving non-linear real arithmetic formulas the assignment could contain other variables or freshly introduced variables.</li>
<li><code>std::vector&lt;FormulaT&gt; lemmas() const</code> Returns valid formulas, which we call lemmas. For instance the <code>ICPModule</code> might return lemmas being splitting decisions, which need to be processed in, e.g., a SAT solver. A <em>splitting decision</em> has in general the form <code>(c_1 and ... and c_n) -&gt; (p &lt;= r or p &gt; r)</code> where c_1, .., c_n are constraints of the set of currently being checked constraints (forming a <em>premise</em>), p is a polynomial (in the most cases consisting only of one variable) and r being a rational number. Hence, splitting decisions always form a tautology. We recommend to use the <code>ICPModule</code> only in strategies with a preceding <code>SATModule</code>. The same holds for the <code>LRAModule</code>, <code>VSModule</code>, and <code>CADModule</code> if used on QF_NIA formulas. Here, again, splitting decisions might be communicated.</li>
</ul>
<p>Of course, the Manager interface contains more methods that can be found at Manager.</p>
<h2><a class="anchor" id="autotoc_md27"></a>
Syntax of formulas</h2>
<p>The class Formula represents SMT formulas, which are defined according to the following abstract grammar</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{array}{rccccccccccccc} p &amp;\quad ::=\quad &amp; a &amp; | &amp; b &amp; | &amp; x &amp; | &amp; (p + p) &amp; | &amp; (p \cdot p) &amp; | &amp; (p^e) \\ v &amp;\quad ::=\quad &amp; u &amp; | &amp; x \\ s &amp;\quad ::=\quad &amp; f(v,\ldots,v) &amp; | &amp; u &amp; | &amp; x \\ e &amp;\quad ::=\quad &amp; s = s \\ c &amp;\quad ::=\quad &amp; p = 0 &amp; | &amp; p &lt; 0 &amp; | &amp; p \leq 0 &amp; | &amp; p &gt; 0 &amp; | &amp; p \geq 0 &amp; | &amp; p \neq 0 \\ \varphi &amp;\quad ::=\quad &amp; c &amp; | &amp; (\neg \varphi) &amp; | &amp; (\varphi\land\varphi) &amp; | &amp; (\varphi\lor\varphi) &amp; | &amp; (\varphi\rightarrow\varphi) &amp; | \\ &amp;&amp; (\varphi\leftrightarrow\varphi) &amp; | &amp; (\varphi\oplus\varphi) \end{array} \]" src="../../form_33.png" width="456" height="104"/>
</p>
<p>where <img class="formulaInl" alt="$a$" src="../../form_34.png" width="6" height="6"/> is a rational number, <img class="formulaInl" alt="$e$" src="../../form_35.png" width="5" height="6"/> is a natural number greater one, <img class="formulaInl" alt="$b$" src="../../form_36.png" width="5" height="10"/> is a <em>Boolean variable</em> and the <em>arithmetic variable</em> <img class="formulaInl" alt="$x$" src="../../form_37.png" width="8" height="6"/> is an inherently existential quantified and either real- or integer-valued. We call <img class="formulaInl" alt="$p$" src="../../form_20.png" width="8" height="9"/> a <em>polynomial</em> and use a multivariate polynomial with rationals as coefficients to represent it. The *uninterpreted function <img class="formulaInl" alt="$f$" src="../../form_38.png" width="8" height="13"/> is of a certain <em>order</em> <img class="formulaInl" alt="$o(f)$" src="../../form_39.png" width="23" height="14"/> and each of its <img class="formulaInl" alt="$o(f)$" src="../../form_39.png" width="23" height="14"/> arguments are either an arithmetic variable or an <em>uninterpreted variable</em> <img class="formulaInl" alt="$u$" src="../../form_40.png" width="9" height="6"/>, which is also inherently existential quantified, but has no domain specified. Than an <em>uninterpreted equation</em> <img class="formulaInl" alt="$e$" src="../../form_35.png" width="5" height="6"/> has either an uninterpreted function, an uninterpreted variable or an arithmetic variable as left-hand respectively right-hand side. A <em>constraint</em> <img class="formulaInl" alt="$c$" src="../../form_41.png" width="5" height="6"/> compares a polynomial to zero, using a <em>relation symbol</em>. Furthermore, we keep constraints in a normalized representation to be able to differ them better.</p>
<h2><a class="anchor" id="autotoc_md28"></a>
Boolean combinations of constraints and Boolean variables</h2>
<p>For more information, check out the docs of <a href="https://github.com/ths-rwth/carl">CArL</a>.</p>
<p>A formula is stored as a directed acyclic graph, where the intermediate nodes represent the Boolean operations on the sub-formulas represented by the successors of this node. The leaves (nodes without successor) contain either a Boolean variable, a constraint or an uninterpreted equality. Equal formulas, that is formulas being leaves and containing the same element or formulas representing the same operation on the same sub-formulas, are stored only once.</p>
<p>The construction of formulas, which are represented by the FormulaT class, is mainly based on the presented abstract grammar. A formula being a leaf wraps the corresponding objects representing a Boolean variable, a constraint or an uninterpreted equality. A Boolean combination of Boolean variables, constraints and uninterpreted equalities consists of a Boolean operator and the sub-formulas it interconnects. For this purpose we either firstly create a set of formulas containing all sub-formulas and then construct the Formula or (if the formula shall not have more than three sub-formulas) construct the formula directly passing the operator and sub-formulas. Formulas, constraints and uninterpreted equalities are non-mutable, once they are constructed.</p>
<p>We give a small example constructing the formula </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[(\neg b\ \land\ x^2-y&lt;0\ \land\ 4x+y-8y^7=0 )\ \rightarrow\ (\neg(x^2-y&lt;0)\ \lor\ b ),\]" src="../../form_42.png" width="359" height="16"/>
</p>
<p> with the Boolean variable $b$ and the real-valued variables <img class="formulaInl" alt="$x$" src="../../form_37.png" width="8" height="6"/> and <img class="formulaInl" alt="$y$" src="../../form_43.png" width="8" height="9"/>, for demonstration. Furthermore, we construct the UF formula </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[v = f(u,u)\ \oplus\ w \neq u\]" src="../../form_44.png" width="116" height="14"/>
</p>
<p> with <img class="formulaInl" alt="$u$" src="../../form_40.png" width="9" height="6"/>, <img class="formulaInl" alt="$v$" src="../../form_45.png" width="8" height="6"/> and <img class="formulaInl" alt="$w$" src="../../form_46.png" width="10" height="6"/> being uninterpreted variables of not specified domains <img class="formulaInl" alt="$S$" src="../../form_47.png" width="9" height="10"/> and <img class="formulaInl" alt="$T$" src="../../form_48.png" width="10" height="9"/>, respectively, and $f$ is an uninterpreted function with not specified domain <img class="formulaInl" alt="$T^{S\times S}$" src="../../form_49.png" width="31" height="11"/>.</p>
<p>Firstly, we show how to create real valued (integer valued analogously with <code>VT_INT</code>), Boolean and uninterpreted variables: </p><pre class="fragment">carl::Variable x = smtrat::newVariable( "x", carl::VariableType::VT_REAL );
carl::Variable y = smtrat::newVariable( "y", carl::VariableType::VT_REAL );
carl::Variable b = smtrat::newVariable( "b", carl::VariableType::VT_BOOL );
carl::Variable u = smtrat::newVariable( "u", carl::VariableType::VT_UNINTERPRETED );
carl::Variable v = smtrat::newVariable( "v", carl::VariableType::VT_UNINTERPRETED );
carl::Variable w = smtrat::newVariable( "w", carl::VariableType::VT_UNINTERPRETED );
</pre><p> Uninterpreted variables, functions and function instances combined in equations or inequalities comparing them are constructed the following way. </p><pre class="fragment">carl::Sort sortS = smtrat::newSort( "S" );
carl::Sort sortT = smtrat::newSort( "T" );
carl::UVariable uu( u, sortS );
carl::UVariable uv( v, sortT );
carl::UVariable uw( w, sortS );
carl::UninterpretedFunction f = smtrat::newUF( "f", sortS, sortS, sortT );
carl::UFInstance f1 = smtrat::newUFInstance( f, uu, uw );
carl::UEquality ueqA( uv, f1, false );
carl::UEquality ueqB( uw, uu, true );
</pre><p> Next we see an example how to create polynomials, which form the left-hand sides of the constraints: </p><pre class="fragment">smtrat::Poly px( x );
smtrat::Poly py( y );
smtrat::Poly lhsA = px.pow(2) - py;
smtrat::Poly lhsB = smtrat::Rational(4) * px + py - smtrat::Rational(8) * py.pow(7);
</pre><p> Constraints can then be constructed as follows: </p><pre class="fragment">smtrat::ConstraintT constraintA( lhsA, carl::Relation::LESS );
smtrat::ConstraintT constraintB( lhsB, carl::Relation::EQ );
</pre><p> Now, we can construct the atoms of the Boolean formula </p><pre class="fragment">smtrat::FormulaT atomA( constraintA );
smtrat::FormulaT atomB( constraintB );
smtrat::FormulaT atomC( b );
smtrat::FormulaT atomD( ueqA );
smtrat::FormulaT atomE( ueqB );
</pre><p> and the formulas itself (either with a set of arguments or directly): </p><pre class="fragment">smtrat::FormulasT subformulasA;
subformulasA.insert( smtrat::FormulaT( carl::FormulaType::NOT, atomC ) );
subformulasA.insert( atomA );
subformulasA.insert( atomB );
smtrat::FormulaT phiA( carl::FormulaType::AND, std::move(subformulasA) );
smtrat::FormulaT phiB( carl::FormulaType::NOT, atomA )
smtrat::FormulaT phiC( carl::FormulaType::OR, phiB, atomC );
smtrat::FormulaT phiD( carl::FormulaType::IMPLIES, phiA, phiC );
smtrat::FormulaT phiE( carl::FormulaType::XOR, atomD, atomE );
</pre><p> Note, that <img class="formulaInl" alt="$\land$" src="../../form_50.png" width="8" height="9"/> and <img class="formulaInl" alt="$\lor$" src="../../form_51.png" width="8" height="9"/> are <img class="formulaInl" alt="$n$" src="../../form_52.png" width="9" height="6"/>-ary constructors, <img class="formulaInl" alt="$\neg$" src="../../form_53.png" width="8" height="4"/> is a unary constructor and all the other Boolean operators are binary.</p>
<h2><a class="anchor" id="autotoc_md29"></a>
Normalized constraints</h2>
<p>A normalized constraint has the form </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[a_1\overbrace{x_{1,1}^{e_{1,1}}\cdot\ldots\cdot x_{1,k_1}^{e_{1,k_1}}}^{m_1}+\ldots+a_n\overbrace{x_{n,1}^{e_{n,1}}\cdot\ldots\cdot x_{n,k_n}^{e_{n,k_n}}}^{m_n}\ + \ d\ \sim \ 0\]" src="../../form_54.png" width="309" height="34"/>
</p>
<p> with <img class="formulaInl" alt="$n\geq0$" src="../../form_55.png" width="31" height="11"/>, the * <img class="formulaInl" alt="$i$" src="../../form_56.png" width="5" height="9"/>th coefficient* <img class="formulaInl" alt="$a_i$" src="../../form_57.png" width="10" height="9"/> being an integral number ( <img class="formulaInl" alt="$\neq 0$" src="../../form_58.png" width="19" height="13"/>), <img class="formulaInl" alt="$d$" src="../../form_59.png" width="6" height="10"/> being a integral number, <img class="formulaInl" alt="$x_{i,j_i}$" src="../../form_60.png" width="21" height="10"/> being a real- or integer-valued variable and <img class="formulaInl" alt="$e_{i,j_i}$" src="../../form_61.png" width="19" height="10"/> being a natural number greater zero (for all <img class="formulaInl" alt="$1\leq i\leq n$" src="../../form_62.png" width="51" height="11"/> and <img class="formulaInl" alt="$1\leq j_i\leq k_i$" src="../../form_63.png" width="59" height="13"/>). Furthermore, it holds that <img class="formulaInl" alt="$x_{i,j_i}\neq x_{i,l_i}$" src="../../form_64.png" width="60" height="14"/> if <img class="formulaInl" alt="$j_i\neq l_i$" src="../../form_65.png" width="34" height="13"/> (for all <img class="formulaInl" alt="$1\leq i\leq n$" src="../../form_62.png" width="51" height="11"/> and <img class="formulaInl" alt="$1\leq j_i, l_i\leq k_i$" src="../../form_66.png" width="71" height="13"/>) and <img class="formulaInl" alt="$m_{i_1}\neq m_{i_2}$" src="../../form_67.png" width="56" height="14"/> if <img class="formulaInl" alt="$i_1\neq i_2$" src="../../form_68.png" width="36" height="13"/> (for all <img class="formulaInl" alt="$1\leq i_1,i_2\leq n$" src="../../form_69.png" width="73" height="11"/>). If <img class="formulaInl" alt="$n$" src="../../form_52.png" width="9" height="6"/> is <img class="formulaInl" alt="$0$" src="../../form_70.png" width="8" height="9"/> then <img class="formulaInl" alt="$d$" src="../../form_59.png" width="6" height="10"/> is <img class="formulaInl" alt="$0$" src="../../form_70.png" width="8" height="9"/> and <img class="formulaInl" alt="$\sim$" src="../../form_71.png" width="9" height="4"/> is either <img class="formulaInl" alt="$=$" src="../../form_72.png" width="9" height="4"/> or <img class="formulaInl" alt="$&lt;$" src="../../form_73.png" width="9" height="9"/>. In the former case we have the normalized representation of any variable-free consistent constraint, which semantically equals <code>true</code>, and in the latter case we have the normalized representation of any variable-free inconsistent constraint, which semantically equals <code>false</code>. Note that the monomials and the variables in them are ordered according the \polynomialOrder of \carl. Moreover, the first coefficient of a normalized constraint (with respect to this order) is always positive and the greatest common divisor of <img class="formulaInl" alt="$a_1,\ldots,\ a_n,\ d$" src="../../form_74.png" width="74" height="13"/> is <img class="formulaInl" alt="$1$" src="../../form_75.png" width="5" height="9"/>. If all variable are integer valued the constraint is further simplified to </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\frac{a_1}{g}\cdot m_1\ +\ \ldots\ +\ \frac{a_n}{g}\cdot m_n\ + \ d'\ \sim' \ 0,\]" src="../../form_76.png" width="215" height="26"/>
</p>
<p> where <img class="formulaInl" alt="$g$" src="../../form_77.png" width="8" height="9"/> is the greatest common divisor of <img class="formulaInl" alt="$a_1,\ldots,\ a_n$" src="../../form_78.png" width="56" height="9"/>, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\sim'=\left\{ \begin{array}{ll} \leq, &amp;\text{ if }\sim\text{ is }&lt; \\ \geq, &amp;\text{ if }\sim\text{ is }&gt; \\ \sim, &amp;\text{ otherwise } \end{array} \right.\]" src="../../form_79.png" width="131" height="46"/>
</p>
<p> and </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ d' = \left\{ \begin{array}{ll} \lceil\frac{d}{g}\rceil &amp;\text{ if }\sim'\text{ is }\leq \\ \lfloor\frac{d}{g}\rfloor &amp;\text{ if }\sim'\text{ is }\geq \\ \frac{d}{g} &amp;\text{ otherwise } \end{array} \right.\]" src="../../form_80.png" width="141" height="54"/>
</p>
<p> If additionally <img class="formulaInl" alt="$\frac{d}{g}$" src="../../form_81.png" width="8" height="19"/> is not integral and <img class="formulaInl" alt="$\sim'$" src="../../form_82.png" width="13" height="9"/> is <img class="formulaInl" alt="$=$" src="../../form_72.png" width="9" height="4"/>, the constraint is simplified <img class="formulaInl" alt="$0&lt;0$" src="../../form_83.png" width="30" height="10"/>, or if <img class="formulaInl" alt="$\sim'$" src="../../form_82.png" width="13" height="9"/> is <img class="formulaInl" alt="$\neq$" src="../../form_84.png" width="9" height="13"/>, the constraint is simplified <img class="formulaInl" alt="$0=0$" src="../../form_85.png" width="30" height="9"/>.</p>
<p>We do some further simplifications, such as the elimination of multiple roots of the left-hand sides in equations and inequalities with the relation symbol <img class="formulaInl" alt="$\neq$" src="../../form_84.png" width="9" height="13"/>, e.g., <img class="formulaInl" alt="$x^3=0$" src="../../form_86.png" width="36" height="11"/> is simplified to <img class="formulaInl" alt="$x=0$" src="../../form_87.png" width="31" height="9"/>. We also simplify constraints whose left-hand sides are obviously positive (semi)/negative (semi) definite, e.g., <img class="formulaInl" alt="$x^2\leq 0$" src="../../form_88.png" width="36" height="14"/> is simplified to <img class="formulaInl" alt="$x^2=0$" src="../../form_89.png" width="36" height="11"/>, which again can be simplified to <img class="formulaInl" alt="$x=0$" src="../../form_87.png" width="31" height="9"/> according to the first simplification rule.</p>
<h2><a class="anchor" id="autotoc_md30"></a>
Linking</h2>
<p>[Todo: example how linking works] </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
