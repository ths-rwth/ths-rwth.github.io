<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SMT-RAT: System architecture</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../logo_smtrat.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SMT-RAT
   &#160;<span id="projectnumber">24.02</span>
   </div>
   <div id="projectbrief">Toolbox for Strategic and Parallel Satisfiability-Modulo-Theories Solving</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('dc/da6/architecture.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">System architecture </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__builds_ths_smt_smtrat_doc_markdown_03_architecture"></a> </p>
<h1><a class="anchor" id="autotoc_md5"></a>
Different libraries</h1>
<p>THe different parts of SMT-RAT are split into multiple libraries (in the sense of a shared object library) that are responsible for the following tasks:</p>
<ul>
<li><code>smtrat-analyzer</code>: static analysis of input formulae;</li>
<li><code>smtrat-cad</code>: back all CAD-based techniques;</li>
<li><code>smtrat-common</code>: common definitions and includes;</li>
<li><code>smtrat-max-smt</code>: takes care of max SMT queries;</li>
<li><code>smtrat-mcsat</code>: utilities for the MCSAT-based solver;</li>
<li><code>smtrat-modules</code>: all regular SMT-RAT modules;</li>
<li><code>smtrat-optimization</code>: takes care of optimization queries;</li>
<li><code>smtrat-qe</code>: methods for quantifier elimination;</li>
<li><code>smtrat-solver</code>: core solving infrastructure;</li>
<li><code>smtrat-strategies</code>: strategies for SMT solving;</li>
<li><code>smtrat-unsat-cores</code>: takes care of unsat core computations.</li>
</ul>
<p>All of these yield a library, while a full-fledged SMT solver is build from the <code>cli/</code> path, in particular the <code><a class="el" href="../../de/d8f/smtratSolver_8cpp.html">cli/smtratSolver.cpp</a></code>.</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Software design</h1>
<p>The architecture of SMT-RAT puts its focus on modularity and composability of different solving techniques. Every solving technique, for example SAT solving or the simplex method, is encapsulated in a (derivation of the) module class. These modules are composed to a strategy that governs which modules are used in what order. The execution of a strategy is incumbent upon the manager, that also offers an interface for basic SMT solving to the outside.</p>
<p>More advanced solving techniques like quantifier elimination, computing unsatisfiable cores, or tackling max SMT and optimization queries are implemented as individual components in the frontend. The frontend implements (most of) an SMT-LIB compatible interface and can either be used by a generic SMT-LIB parser, or an external tool. This structure is shown in the following picture.</p>
<p><img src="../../system_architecture.png" alt="" class="inline" title="System architecture"/></p>
<p>The parser itself is implemented in <code>cli/parser/</code> and run from <code><a class="el" href="../../de/d93/execute__smtlib_8h.html">cli/tools/execute_smtlib.h</a></code>. The template argument <code>Executor</code> is usually instantiated with the executor from <code><a class="el" href="../../dd/d8c/Executor_8h.html">cli/tools/Executor.h</a></code> which corresponds to the frontend. The components in the frontend are taken from the respective SMT-RAT libraries.</p>
<p>The manager is a generic class from <code><a class="el" href="../../d1/da0/Manager_8h.html">smtrat-solver/Manager.h</a></code> that every strategy (from <code>smtrat-strategies/</code>) inherits from and only constructs the strategy graph in its constructor. The strategy graph is at the core of the composition of SMT-RAT modules and the following picture shows how a single module is embedded in a strategy.</p>
<p><img src="../../module_in_strategy.png" alt="" class="inline" title="Module in a strategy"/></p>
<p>Every module has (a pointer to) a set of received formulae that represent its input and a set of passed formulae that represent the formula that is passed on to some backend. The module may "solve" the query from its input on its own, or it may pass (one or more) queries to its backends (in this case B-1, B-2 and B-3). Arrows to backends may be labeled with conditions that restrict whether this particular backend can be used, for example checking whether the passed formulae are linear, contain integer variables or bit-vector formulae.</p>
<p>When a module issues a backend call the manager identifies all suitable backend modules (where the condition evaluates to <code>true</code>) and calls all backend modules on the passed formulae. This happens either sequentially (until one backend module solves the query) or in parallel.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Modules</h1>
<p>A module <img class="formulaInl" alt="$m$" src="../../form_1.png" width="13" height="6"/> holds a set of formulas, called its set of received formulas and denoted by <img class="formulaInl" alt="$C_{rcv}(m)$" src="../../form_2.png" width="44" height="14"/>. The main function of a module is <code>check(bool full)</code>, which either decides whether <img class="formulaInl" alt="$C_{rcv}(m)$" src="../../form_2.png" width="44" height="14"/> is satisfiable or not, returning <code>SAT</code> or <code>UNSAT</code>, respectively, or returns <code>UNKNOWN</code>. A set of formulas is semantically defined by their conjunction. If the function's argument <code>full</code> is set to <code>false</code>, the underlying procedure of <img class="formulaInl" alt="$m$" src="../../form_1.png" width="13" height="6"/> is allowed to omit hard obstacles during solving at the cost of returning <code>UNKNOWN</code> in more cases. We can manipulate <img class="formulaInl" alt="$C_{rcv}(m)$" src="../../form_2.png" width="44" height="14"/> by adding (removing) formulas <img class="formulaInl" alt="$\varphi$" src="../../form_3.png" width="8" height="9"/> to (from) it with <code>add(\f$\varphi\f$)</code> (<code>remove(\f$\varphi\f$)</code>). Usually, <img class="formulaInl" alt="$C_{rcv}(m)$" src="../../form_2.png" width="44" height="14"/> is only slightly changed between two consecutive <code>check</code> calls, hence, the solver's performance can be significantly improved if a module works incrementally and supports backtracking. In case <img class="formulaInl" alt="$m$" src="../../form_1.png" width="13" height="6"/> determines the unsatisfiability of <img class="formulaInl" alt="$C_{rcv}(m)$" src="../../form_2.png" width="44" height="14"/>, it has to compute at least one preferably small infeasible subset <img class="formulaInl" alt="$C_{inf}(m)\subseteq C_{rcv}(m)$" src="../../form_4.png" width="106" height="14"/>. Moreover, a module can specify <em>lemmas</em>, which are valid formulas. They encapsulate information which can be extracted from a module's internal state and propagated among other modules. Furthermore, a module itself can ask other modules for the satisfiability of its <em>set of passed formulas</em> denoted by <img class="formulaInl" alt="$C_{pas}(m)$" src="../../form_5.png" width="44" height="14"/>, if it invokes the procedure <code>runBackends(bool full)</code> (controlled by the manager). It thereby delegates work to modules that may be more suitable for the problem at hand.</p>
<h1><a class="anchor" id="autotoc_md8"></a>
Strategy</h1>
<p>SMT-RAT allows a user to decide how to compose the modules. For this purpose we provide a graphical user interface, where the user can create a <em>strategy</em> specifying this composition. A strategy is a directed tree <img class="formulaInl" alt="$T:=(V, E)$" src="../../form_6.png" width="63" height="14"/> with a set <img class="formulaInl" alt="$V$" src="../../form_7.png" width="10" height="10"/> of modules as nodes and <img class="formulaInl" alt="$E\subseteq V\times \Omega\times\Sigma\times V$" src="../../form_8.png" width="110" height="13"/>, with <img class="formulaInl" alt="$\Omega$" src="../../form_9.png" width="9" height="10"/> being the set of <em>conditions</em> and <img class="formulaInl" alt="$\Sigma$" src="../../form_10.png" width="9" height="10"/> being the set of <em>priority values</em>. A condition is an arbitrary Boolean combination of formula properties, such as propositions about the Boolean structure of the formula, e.g., whether it is in conjunctive normal form (CNF), about the constraints, \eg whether it contains equations, or about the polynomials, e.g., whether they are linear. Furthermore, each edge carries a unique priority value from <img class="formulaInl" alt="$\Sigma=\{1,\ \ldots,\ |E|\}$" src="../../form_11.png" width="96" height="14"/>.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Manager</h1>
<p>The manager holds the strategy and the SMT solver's input formula <img class="formulaInl" alt="$C_{input}$" src="../../form_12.png" width="33" height="14"/>. Initially, the manager calls the method <code>check</code> of the module <img class="formulaInl" alt="$m_r$" src="../../form_13.png" width="18" height="9"/> given by the root of the strategy with <img class="formulaInl" alt="$C_{rcv}(m_r) = C_{input}$" src="../../form_14.png" width="100" height="14"/>. Whenever a module <img class="formulaInl" alt="$m\in V$" src="../../form_15.png" width="38" height="11"/> calls <code>runBackends</code>, the manager adds a solving task <img class="formulaInl" alt="$(\sigma, m, m')$" src="../../form_16.png" width="53" height="14"/> to its priority queue <img class="formulaInl" alt="$Q$" src="../../form_17.png" width="10" height="13"/> of solving tasks (ordered by the priority value), if there exists an edge <img class="formulaInl" alt="$(m, \omega, \sigma, m')\in E$" src="../../form_18.png" width="91" height="14"/> in the strategy such that <img class="formulaInl" alt="$\omega$" src="../../form_19.png" width="9" height="6"/> holds for <img class="formulaInl" alt="$C_{pas}(m)$" src="../../form_5.png" width="44" height="14"/>. If a processor <img class="formulaInl" alt="$p$" src="../../form_20.png" width="8" height="9"/> on the machine where SMT-RAT is executed on is available, the first solving task of <img class="formulaInl" alt="$Q$" src="../../form_17.png" width="10" height="13"/> is assigned to <img class="formulaInl" alt="$p$" src="../../form_20.png" width="8" height="9"/> and popped from <img class="formulaInl" alt="$Q$" src="../../form_17.png" width="10" height="13"/>. The manager thereby starts the method <code>check</code> of <img class="formulaInl" alt="$m'$" src="../../form_21.png" width="15" height="10"/> with <img class="formulaInl" alt="$C_{rcv}(m') = C_{pas}(m)$" src="../../form_22.png" width="109" height="14"/> and passes the result (including infeasible subsets and lemmas) back to <img class="formulaInl" alt="$m$" src="../../form_1.png" width="13" height="6"/>. The module <img class="formulaInl" alt="$m$" src="../../form_1.png" width="13" height="6"/> can now benefit in its solving and reasoning process from this shared information. Note that a strategy-based composition of modules works incrementally and supports backtracking not just within one module but as a whole. This is realized by a mapping in each module <img class="formulaInl" alt="$m$" src="../../form_1.png" width="13" height="6"/> of its passed formulas <img class="formulaInl" alt="$\varphi \in C_{pas}(m)$" src="../../form_23.png" width="68" height="14"/> to sets <img class="formulaInl" alt="$R_1,\ldots, R_n \subseteq C_{rcv}(m)$" src="../../form_24.png" width="119" height="14"/> such that each <img class="formulaInl" alt="$R_i$" src="../../form_25.png" width="13" height="13"/> forms a reason why <img class="formulaInl" alt="$m$" src="../../form_1.png" width="13" height="6"/> included <img class="formulaInl" alt="$\varphi$" src="../../form_3.png" width="8" height="9"/> in <img class="formulaInl" alt="$C_{pas}(m)$" src="../../form_5.png" width="44" height="14"/> to ask for its satisfiability. In order to exploit the incrementality of the modules, all parallel executed backends terminate in a consistent state (instead of just being killed), if one of them finds an answer.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Procedures implemented as modules</h1>
<p>The heart of an SMT solver usually forms a SAT solver. In SMT-RAT, the module SATModule abstracts the received formulae to propositional logic and uses the efficient SAT solver MiniSat <b>[minisat]</b> to find a Boolean assignment of the abstraction. It invokes <code>runBackends</code> where the passed formulae of the SATModule contain the constraints abstracted by the assigned Boolean variables in a less-lazy fashion <b>[sebastiani2007lazy]</b>. [Todo: Make a concise description here, refer to extensive discussion of modules]</p>
<h1><a class="anchor" id="autotoc_md11"></a>
Infeasible subsets and lemmas</h1>
<p>Infeasible subsets and lemmas, which contain only formulas from <img class="formulaInl" alt="$C_{pas}(SATModule)$" src="../../form_26.png" width="104" height="14"/> of a preceding SATModule, prune its Boolean search space and hence the number of theory calls. Smaller infeasible subsets are usually more advantageous, because they make larger cuts in the search space. We call lemmas containing new constraints inventive lemmas (non-inventive otherwise). They might enlarge the Boolean search space, but they can reduce the complexity of later theory calls. When using inventive lemmas, it is important to ensure that the set possible constraints introduced in such lemmas is finite for a given module and a given input formula. Otherwise, the termination of this procedure cannot be guaranteed. In general, any module might contribute lemmas and all preceding modules in the solving hierarchy can directly involve them in their search for satisfiability. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
