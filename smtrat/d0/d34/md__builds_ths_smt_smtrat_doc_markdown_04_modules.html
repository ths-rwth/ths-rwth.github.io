<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SMT-RAT: Modules</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../logo_smtrat.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SMT-RAT
   &#160;<span id="projectnumber">24.02</span>
   </div>
   <div id="projectbrief">Toolbox for Strategic and Parallel Satisfiability-Modulo-Theories Solving</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d0/d34/md__builds_ths_smt_smtrat_doc_markdown_04_modules.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Modules </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this chapter we explain how to implement further modules. A module is a derivation of the class <code>Module</code> and we give an introduction to its members, interfaces and auxiliary methods in the following of this chapter. A new module and, hence, the corresponding C++ source and header files can be easily created when using the script <code>writeModules.py</code>. Its single argument is the module's name and the script creates a new folder in <code>src/lib/modules/</code> containing the source and header file with the interfaces yet to implement. Furthermore, it is optional to create the module having a template parameter forming a settings object as explained in sec:auxfunctions. A new module should be created only this way, as the script takes care of a correct integration of the corresponding code into SMT-RAT. A module can be deleted belatedly by just removing the complete folder it is implemented in.</p>
<h1><a class="anchor" id="autotoc_md13"></a>
Main members of a module</h1>
<p>Here is an overview of the most important members of the class <code>Module</code>.</p>
<ul>
<li><code>vector&lt;FormulasT&gt; mInfeasibleSubsets</code>: stores the infeasible subsets of the so far received formulas, if the module determined that their conjunction is not satisfiable.</li>
<li><code>Manager* const mpManager</code>: a pointer to the manager which maintains the allocation of modules (including this one) to other modules, when they call a backend for a certain formula.</li>
<li><code>const ModuleInput* mpReceivedFormula</code>: the received formula stores the conjunction of the so far received formulas, which this module considers for a satisfiability check. These formulas are of the type FormulaT and the ModuleInput is basically a list of such formulas, which never contains a formula more than once.</li>
<li><code>ModuleInput* mpPassedFormula</code>: the passed formula stores the conjunction of the formulas which this module passes to a backend to be solved for satisfiability. There are dedicated methods to change this member, which are explained in the following.</li>
</ul>
<p>The received formula of a module is the passed formula of the preceding module. The owner is the preceding module, hence, a module has only read access to its received formula. The <code>ModuleInput</code> also stores a mapping of a sub-formula in the passed formula of a module to its origins in the received formula of the same module. Why this mapping is essential and how we can construct it is explained in Section sec:runbackend.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
Interfaces to implement</h1>
<p>In the following we explain which methods must be implemented in order to fill the module's interfaces with life. All these methods are the core implementation and wrapped by the actual interfaces. This way the developer of a new module needs only to take care about the implementation of the actual procedure for the satisfiability check. All infrastructure-related actions are performed by the actual interface.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
Informing about a constraint</h2>
<pre class="fragment">bool MyModule::informCore( const Formula&amp; _constraint )
{
    // Write the implementation here.
}
</pre><p> Informs the module about the existence of the given constraint (actually it is a formula wrapping a constraint) usually before it is actually added to this module for consideration of a later satisfiability check. At least it can be expected, that this method is called, before a formula containing the given constraint is added to this module for consideration of a later satisfiability check. This information might be useful for the module, e.g., for the initialization of the data structures it uses. If the module can already decide whether the given constraint is not satisfiable itself, it returns <code>false</code> otherwise <code>true</code>.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Adding a received formula</h2>
<pre class="fragment">bool MyModule::addCore( const ModuleInput::const_iterator )
{
    // Write the implementation here.
}
</pre><p> Adds the formula at the given position in the conjunction of received formulas, meaning that this module has to include this formula in the next satisfiability check. If the module can already decide (with very low effort) whether the given formula is not satisfiable in combination with the already received formulas, it returns <code>false</code> otherwise <code>true</code>. This is usually determined using the solving results this module has stored after the last consistency checks. In the most cases the implementation of a new module needs some initialization in this method.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
Removing a received formula</h2>
<pre class="fragment">void MyModule::removeCore( const ModuleInput::iterator )
{
    // Write the implementation here.
}
</pre><p> Removes the formula at the given position from the received formula. Everything, which has been stored in this module and depends on this formula must be removed.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
Checking for satisfiability</h2>
<pre class="fragment">Answer MyModule::checkCore( bool )
{
    // Write the implementation here.
}
</pre><p> Implements the actual satisfiability check of the conjunction of formulas, which are in the received formula. There are three options how this module can answer: it either determines that the received formula is satisfiable and returns <code>true</code>, it determines unsatisfiability and returns <code>false</code>, or it cannot give a conclusive answer and returns <code>UNKNOWN</code>. A module has also the opportunity to reason about the conflicts occurred, if it determines unsatisfiability. For this purpose it has to store at least one infeasible subset of the set of so far received formulas. If the method <code>check</code> is called with its argument being <code>false</code>, this module is allowed to omit hard obstacles during solving at the cost of returning <code>UNKNOWN</code> in more cases, we refer to as a <em>lightweight check</em>.</p>
<h2><a class="anchor" id="autotoc_md19"></a>
Updating the model/satisfying assignment</h2>
<pre class="fragment">void MyModule::updateModel()
{
    // Write the implementation here.
}
</pre><p> If this method is called, the last result of a satisfiability check was <code>true</code> and no further formulas have been added to the received formula, this module needs to fill its member <code>mModel</code> with a model. This model must be complete, that is all variables and uninterpreted functions occurring in the received formula must be assigned to a value of their corresponding domain. It might be necessary to involve the backends using the method <code>getBackendsModel()</code> (if they have been asked for the satisfiability of a sub-problem). It stores the model of one backend into the model of this module.</p>
<h1><a class="anchor" id="autotoc_md20"></a>
Running backend modules</h1>
<p>Modules can always call a backend in order to check the satisfiability of any conjunction of formulas. Fortunately, there is no need to manage the assertion of formulas to or removing of formulas from the backend. This would be even more involved as we do allow changing the backend if it is appropriate (more details to this are explained in Chapter chapter:composingats. Running the backend is done in two steps:</p>
<ol type="1">
<li>Change the passed formula to the formula which should be solved by the backend. Keep in mind, that the passed formula could still contain formulas of the previous backend call.</li>
<li>Call <code>runBackends(full)</code>, where <code>full</code> being <code>false</code> means that the backends have to perform a lightweight check.</li>
</ol>
<p>The first step is a bit more tricky, as we need to know which received formulas led to a passed formula. For this purpose the <code>ModuleInput</code> maintains a mapping from a passed sub-formula to one or more conjunctions of received sub-formulas. We give a small example. Let us assume that a module has so far received the following constraints (wrapped in formulas) </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[c_0:x\leq0,\ c_1:x\geq 0,\ c_2:x=0\]" src="../../form_27.png" width="174" height="11"/>
</p>
<p> and combines the first two constraints <img class="formulaInl" alt="$c_0$" src="../../form_28.png" width="10" height="9"/> and <img class="formulaInl" alt="$c_1$" src="../../form_29.png" width="10" height="9"/> to <img class="formulaInl" alt="$c_2$" src="../../form_30.png" width="10" height="9"/>. Afterwards it calls its backend on the only remaining constraint, that means the passed formula contains only <img class="formulaInl" alt="$c_2:x=0$" src="../../form_31.png" width="51" height="11"/>. The mapping of <img class="formulaInl" alt="$c_2$" src="../../form_30.png" width="10" height="9"/> in the passed formula to the received sub-formulas it stems from then is </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[c_2\ \mapsto\ (c_0 \land c_1,\ c_2).\]" src="../../form_32.png" width="108" height="14"/>
</p>
<p>The mapping is maintained automatically and offers two methods to add formulas to the passed formulas: </p><pre class="fragment">pair&lt;ModuleInput::iterator,bool&gt; addReceivedSubformulaToPassedFormula(ModuleInput::const_iterator)
</pre><p> Adds the formula at the given positition in the received formula to the passed formulas. The mapping to its <em>original formulas</em> contains only the set consisting of the formula at the given position in the received formula. </p><pre class="fragment">pair&lt;ModuleInput::iterator,bool&gt; addSubformulaToPassedFormula(const Formula&amp;)
pair&lt;ModuleInput::iterator,bool&gt; addSubformulaToPassedFormula(const Formula&amp;, const Formula&amp;)
pair&lt;ModuleInput::iterator,bool&gt; addSubformulaToPassedFormula(const Formula&amp;, shared_ptr&lt;vector&lt;FormulaT&gt;&gt;&amp;)
</pre><p> Adds the given formula to the passed formulas. It is mapped to the given conjunctions of origins in the received formula. The second argument (if it exists) must only consist of formulas in the received formula.</p>
<p>It returns a pair of a position in the passed formula and a <code>bool</code>. The <code>bool</code> is <code>true</code>, if the formula at the given position in the received formula has been added to the passed formula, which is only the case, if this formula was not yet part of the passed formula. Otherwise, the <code>bool</code> is <code>false</code>. The returned position in the passed formula points to the just added formula.</p>
<p>The vector of conjunctions of origins can be passed as a shared pointer, which is due to a more efficient manipulation of these origins. Some of the current module implementations directly change this vector and thereby achieve directly a change in the origins of a passed formula. \end{itemize} If, by reason of a later removing of received formulas, there is no conjunction of original formulas of a passed formula left (empty conjunction are removed), this passed formula will be automatically removed from the backends and the passed formula. That does also mean, that if we add a formula to the passed formula without giving any origin (which is done by the first version of <code>addSubformulaToPassedFormula</code>), the next call of <code>removeSubformula</code> of this module removes this formula from the passed formula. Specifying received formulas being the origins of a passed formula highly improves the incremental solving performance, so we recommend to do so.</p>
<p>The second step is really just calling <code>runBackends</code> and processing its return value, which can be <code>True</code>, <code>False</code>, or <code>Unknown</code>.</p>
<h1><a class="anchor" id="auxfunctions"></a>
Auxiliary functions</h1>
<p>The Module class provides a rich set of methods for the analysis of the implemented procedures in a module and debugging purposes. Besides all the printing methods, which print the contents of a member of this module to the given output stream, SMT-RAT helps to maintain the correctness of new modules during their development. It therefore provides methods to store formulas with their assumed satisfiability status in order to check them belatedly by any SMT solver which is capable to parse <code>.smt2</code> files and solve the stored formula. To be able to use the following methods, the compiler flag <code>SMTRAT_DEVOPTION_Validation</code> must be activated, which can be easily achieved when using, e.g., <code>ccmake</code>.</p>
<ul>
<li><code>void checkInfSubsetForMinimality(vector&lt;FormulasT&gt;::const_iterator, const string&amp;, unsigned) const</code> This method checks the infeasible subset at the given position for minimality, that is it checks whether there is a subset of it having maximally $n$ elements less while still being infeasible. As for some approaches it is computationally too hard to provide always a minimal infeasible subset, they rather provide infeasible subsets not necessarily being minimal. This method helps to analyze how close the size of the encountered infeasible subsets is to a minimal one.</li>
<li>Another important feature during the development of a new module is the collection of statistics. The script <code>writeModules.py</code> for the creation of a new module automatically adds a class to maintain statistics in the same folder in which the module itself is located. The members of this class store the statistics usually represented by primitive data types as integers and floats. They can be extended as one pleases and be manipulated by methods, which have also to be implemented in this class. SMT-RAT collects and prints these statistics automatically, if its command line interface is called with the option <code>--statistics</code> or <code>-s</code>.</li>
<li>If the script <code>writeModules.py</code> for the creation of a new module is called with the option <code>-s</code>, the module has also a template parameter being a settings object. The different settings objects are stored in the settings file again in the same folder as the module is located. Each of these setting objects assigns all settings, which are usually of type <code>bool</code>, to values. The name of these objects must be of the form XYSettingsN, if the module is called XYModule and with N being preferably a positive integer. Fulfilling these requirements, the settings to compile this module with, can be chosen, e.g. with <code>ccmake</code>, by setting the compiler flag <code>SMTRAT_XY_Settings</code> to N. Within the implementation of the module, its settings can then be accessed using its template parameter <code>Settings</code>. If, for instance, we want to change the control flow of the implemented procedure in the new module depending on a setting <code>mySetting</code> being <code>true</code>, we write the following: <pre class="fragment">..
if(Settings::mySettings)
{
    ..
}
..
</pre> This methodology assures that the right control flow is chosen during compilation and, hence, before runtime.</li>
</ul>
<p>SMT-RAT contributes a toolbox for composing an SMT compliant solver for its supported logics, that means it is incremental, supports backtracking and provides reasons for inconsistency. The resulting solver is either a fully operative SMT solver, which can be applied directly on <code>.smt2</code> files, or a theory solver, which can be embedded into an SMT solver in order to extend its supported logics by those provided by SMT-RAT.</p>
<p>We are talking about composition and toolbox, as SMT-RAT contains implementations of many different procedures to tackle, \eg \supportedLogics, each of them embedded in a module with uniform interfaces. These modules form the tools in the toolbox and it is dedicated to a user how to use them for solving an SMT formula.</p>
<p>In Section sec::strategy we have already introduced a strategy and in the following of this chapter we give a brief introduction to the existing modules equipped with an estimation of their input-based performances.</p>
<h1><a class="anchor" id="autotoc_md21"></a>
Existing module implementation</h1>
<p><a class="el" href="../../d7/da9/available-modules.html">Available modules</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
